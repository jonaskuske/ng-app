{"version":3,"sources":["webpack:///node_modules/@ngxs/store/__ivy_ngcc__/fesm2015/ngxs-store-operators.js"],"names":["isStateOperator","value","patch","patchObject","existing","clone","k","newValue","existingPropValue","newPropValue","Object","assign"],"mappings":"2FAgEA,SAASA,EAAgBC,GACrB,MAAwB,mBAAVA,EAgJlB,SAASC,EAAMC,GACX,OAAO,SAKqBC,GAExB,IAAIC,EAAQ,KACZ,IAAK,MAAMC,KAAKH,EAAa,CAEzB,MAAMI,EAAWJ,EAAYG,GAEvBE,EAAoBJ,EAASE,GAE7BG,EAAeT,EAAgBO,GAC/BA,EAAS,GACTA,EACFE,IAAiBD,IACZH,IACDA,EAAQK,OAAOC,OAAO,GAAI,IAE9BN,EAAMC,GAAKG,GAGnB,OAAOJ,GAASD,GA1OxB","file":"x","sourcesContent":["/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @template T\r\n * @param {?} items - Specific items to append to the end of an array\r\n * @return {?}\r\n */\r\nfunction append(items) {\r\n    return (/**\r\n     * @param {?} existing\r\n     * @return {?}\r\n     */\r\n    function appendOperator(existing) {\r\n        // If `items` is `undefined` or `null` or `[]` but `existing` is provided\r\n        // just return `existing`\r\n        /** @type {?} */\r\n        const itemsNotProvidedButExistingIs = (!items || !items.length) && existing;\r\n        if (itemsNotProvidedButExistingIs) {\r\n            return (/** @type {?} */ (existing));\r\n        }\r\n        if (Array.isArray(existing)) {\r\n            return existing.concat((/** @type {?} */ (items)));\r\n        }\r\n        // For example if some property is added dynamically\r\n        // and didn't exist before thus it's not `ArrayLike`\r\n        return (/** @type {?} */ (items));\r\n    });\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @template T\r\n * @param {...?} operators\r\n * @return {?}\r\n */\r\nfunction compose(...operators) {\r\n    return (/**\r\n     * @param {?} existing\r\n     * @return {?}\r\n     */\r\n    function composeOperator(existing) {\r\n        return operators.reduce((/**\r\n         * @param {?} accumulator\r\n         * @param {?} operator\r\n         * @return {?}\r\n         */\r\n        (accumulator, operator) => operator(accumulator)), existing);\r\n    });\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @template T\r\n * @param {?} value\r\n * @return {?}\r\n */\r\nfunction isStateOperator(value) {\r\n    return typeof value === 'function';\r\n}\r\n/**\r\n * @param {?} value\r\n * @return {?}\r\n */\r\nfunction isUndefined(value) {\r\n    return typeof value === 'undefined';\r\n}\r\n/**\r\n * @template T\r\n * @param {?} value\r\n * @return {?}\r\n */\r\nfunction isPredicate(value) {\r\n    return typeof value === 'function';\r\n}\r\n/**\r\n * @param {?} value\r\n * @return {?}\r\n */\r\nfunction isNumber(value) {\r\n    return typeof value === 'number';\r\n}\r\n/**\r\n * @param {?} index\r\n * @return {?}\r\n */\r\nfunction invalidIndex(index) {\r\n    return Number.isNaN(index) || index === -1;\r\n}\r\n/**\r\n * @template T\r\n * @param {?} value\r\n * @return {?}\r\n */\r\nfunction isNil(value) {\r\n    return value === null || isUndefined(value);\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @template T\r\n * @param {?} operatorOrValue\r\n * @param {?=} existing\r\n * @return {?}\r\n */\r\nfunction retrieveValue(operatorOrValue, existing) {\r\n    // If state operator is a function\r\n    // then call it with an original value\r\n    if (isStateOperator(operatorOrValue)) {\r\n        /** @type {?} */\r\n        const value = operatorOrValue((/** @type {?} */ ((/** @type {?} */ (existing)))));\r\n        return (/** @type {?} */ (value));\r\n    }\r\n    // If operator or value was not provided\r\n    // e.g. `elseOperatorOrValue` is `undefined`\r\n    // then we just return an original value\r\n    if (isUndefined(operatorOrValue)) {\r\n        return (/** @type {?} */ ((/** @type {?} */ (((/** @type {?} */ (existing)))))));\r\n    }\r\n    return (/** @type {?} */ (operatorOrValue));\r\n}\r\n/**\r\n * @template T\r\n * @param {?} condition - Condition can be a plain boolean value or a function,\r\n * that returns boolean, also this function can take a value as an argument\r\n * to which this state operator applies\r\n * @param {?} trueOperatorOrValue - Any value or a state operator\r\n * @param {?=} elseOperatorOrValue - Any value or a state operator\r\n * @return {?}\r\n */\r\nfunction iif(condition, trueOperatorOrValue, elseOperatorOrValue) {\r\n    return (/**\r\n     * @param {?} existing\r\n     * @return {?}\r\n     */\r\n    function iifOperator(existing) {\r\n        // Convert the value to a boolean\r\n        /** @type {?} */\r\n        let result = !!condition;\r\n        // but if it is a function then run it to get the result\r\n        if (isPredicate(condition)) {\r\n            result = condition(existing);\r\n        }\r\n        if (result) {\r\n            return retrieveValue(trueOperatorOrValue, (/** @type {?} */ (existing)));\r\n        }\r\n        return retrieveValue((/** @type {?} */ (elseOperatorOrValue)), (/** @type {?} */ (existing)));\r\n    });\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @template T\r\n * @param {?} value - Value to insert\r\n * @param {?=} beforePosition\r\n * @return {?}\r\n */\r\nfunction insertItem(value, beforePosition) {\r\n    return (/**\r\n     * @param {?} existing\r\n     * @return {?}\r\n     */\r\n    function insertItemOperator(existing) {\r\n        // Have to check explicitly for `null` and `undefined`\r\n        // because `value` can be `0`, thus `!value` will return `true`\r\n        if (isNil(value) && existing) {\r\n            return (/** @type {?} */ (existing));\r\n        }\r\n        // Property may be dynamic and might not existed before\r\n        if (!Array.isArray(existing)) {\r\n            return [(/** @type {?} */ (value))];\r\n        }\r\n        /** @type {?} */\r\n        const clone = existing.slice();\r\n        /** @type {?} */\r\n        let index = 0;\r\n        // No need to call `isNumber`\r\n        // as we are checking `> 0` not `>= 0`\r\n        // everything except number will return false here\r\n        if ((/** @type {?} */ (beforePosition)) > 0) {\r\n            index = (/** @type {?} */ (beforePosition));\r\n        }\r\n        clone.splice(index, 0, (/** @type {?} */ (value)));\r\n        return clone;\r\n    });\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @template T\r\n * @param {?} patchObject\r\n * @return {?}\r\n */\r\nfunction patch(patchObject) {\r\n    return (/**\r\n     * @template U\r\n     * @param {?} existing\r\n     * @return {?}\r\n     */\r\n    function patchStateOperator(existing) {\r\n        /** @type {?} */\r\n        let clone = null;\r\n        for (const k in patchObject) {\r\n            /** @type {?} */\r\n            const newValue = patchObject[k];\r\n            /** @type {?} */\r\n            const existingPropValue = existing[k];\r\n            /** @type {?} */\r\n            const newPropValue = isStateOperator(newValue)\r\n                ? newValue((/** @type {?} */ (existingPropValue)))\r\n                : newValue;\r\n            if (newPropValue !== existingPropValue) {\r\n                if (!clone) {\r\n                    clone = Object.assign({}, ((/** @type {?} */ (existing))));\r\n                }\r\n                clone[k] = newPropValue;\r\n            }\r\n        }\r\n        return clone || existing;\r\n    });\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @template T\r\n * @param {?} selector - Index of item in the array or a predicate function\r\n * that can be provided in `Array.prototype.findIndex`\r\n * @param {?} operatorOrValue - New value under the `selector` index or a\r\n * function that can be applied to an existing value\r\n * @return {?}\r\n */\r\nfunction updateItem(selector, operatorOrValue) {\r\n    return (/**\r\n     * @param {?} existing\r\n     * @return {?}\r\n     */\r\n    function updateItemOperator(existing) {\r\n        /** @type {?} */\r\n        let index = -1;\r\n        if (isPredicate(selector)) {\r\n            index = existing.findIndex(selector);\r\n        }\r\n        else if (isNumber(selector)) {\r\n            index = selector;\r\n        }\r\n        if (invalidIndex(index)) {\r\n            return (/** @type {?} */ (existing));\r\n        }\r\n        /** @type {?} */\r\n        let value = (/** @type {?} */ (null));\r\n        // Need to check if the new item value will change the existing item value\r\n        // then, only if it will change it then clone the array and set the item\r\n        if (isStateOperator(operatorOrValue)) {\r\n            value = operatorOrValue((/** @type {?} */ (existing[index])));\r\n        }\r\n        else {\r\n            value = operatorOrValue;\r\n        }\r\n        // If the value hasn't been mutated\r\n        // then we just return `existing` array\r\n        if (value === existing[index]) {\r\n            return (/** @type {?} */ (existing));\r\n        }\r\n        /** @type {?} */\r\n        const clone = existing.slice();\r\n        clone[index] = (/** @type {?} */ (value));\r\n        return clone;\r\n    });\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @template T\r\n * @param {?} selector - index or predicate to remove an item from an array by\r\n * @return {?}\r\n */\r\nfunction removeItem(selector) {\r\n    return (/**\r\n     * @param {?} existing\r\n     * @return {?}\r\n     */\r\n    function removeItemOperator(existing) {\r\n        /** @type {?} */\r\n        let index = -1;\r\n        if (isPredicate(selector)) {\r\n            index = existing.findIndex(selector);\r\n        }\r\n        else if (isNumber(selector)) {\r\n            index = selector;\r\n        }\r\n        if (invalidIndex(index)) {\r\n            return (/** @type {?} */ (existing));\r\n        }\r\n        /** @type {?} */\r\n        const clone = existing.slice();\r\n        clone.splice(index, 1);\r\n        return clone;\r\n    });\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\nexport { append, compose, iif, insertItem, isStateOperator, patch, removeItem, updateItem };\n\n//# sourceMappingURL=ngxs-store-operators.js.map"]}