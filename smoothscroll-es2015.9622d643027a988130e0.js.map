{"version":3,"sources":["webpack:///node_modules/smoothscroll-polyfill/dist/smoothscroll.js","webpack:///node_modules/smoothscroll-anchor-polyfill/dist/index.mjs"],"names":["module","exports","polyfill","w","window","d","document","documentElement","style","__forceSmoothScrollPolyfill__","userAgent","Element","HTMLElement","original","scroll","scrollTo","scrollBy","elementScroll","prototype","scrollElement","scrollIntoView","now","performance","bind","Date","ROUNDING_TOLERANCE","navigator","RegExp","join","test","undefined","arguments","shouldBailOut","smoothScroll","call","body","left","scrollX","pageXOffset","top","scrollY","pageYOffset","this","scrollLeft","scrollTop","SyntaxError","behavior","scrollableParent","findScrollableParent","parentRects","getBoundingClientRect","clientRects","getComputedStyle","position","x","y","firstArg","TypeError","hasScrollableSpace","el","axis","clientHeight","scrollHeight","clientWidth","scrollWidth","canOverflow","overflowValue","isScrollable","isScrollableY","isScrollableX","parentNode","host","step","context","value","currentX","currentY","elapsed","startTime","Math","cos","PI","method","scrollable","startX","startY","requestAnimationFrame","rootObj","__sap_ES_MODULE__","factory","isESModule","instance","isBrowser","docEl","dummy","createElement","opts","force","__forceSmoothscrollAnchorPolyfill__","destroy","addEventListener","handleClick","trackScrollPositions","handleHashChange","_dummy","removeEventListener","supportsPreventScroll","preppedFocusOption","Object","defineProperty","get","focus","e","pendingFocusChange","extractValue","docElStyle","lastTwoScrollPos","shouldSmoothscroll","valuesToCheck","scrollBehavior","exec","getAttribute","getPropertyValue","fontFamily","i","length","specifiedBehavior","status","trim","isAnchorToLocalElement","tagName","href","anchorPath","pathname","hostname","location","search","focusElement","preventScroll","activeElement","prevTabIndex","setAttribute","outlineStyle","prevOutline","undoOutlineChange","getScrollTarget","hash","target","decodeURIComponent","getElementById","slice","findInParents","element","validate","parentElement","triggerSmoothscroll","clearTimeout","block","setTimeout","evt","defaultPrevented","metaKey","ctrlKey","shiftKey","button","anchor","event","srcElement","preventDefault","history","pushState","title","currentPos","getScrollTop","define","amd","SmoothscrollAnchorPolyfill"],"mappings":"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","file":"x","sourcesContent":["/* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */\n(function () {\n  'use strict';\n\n  // polyfill\n  function polyfill() {\n    // aliases\n    var w = window;\n    var d = document;\n\n    // return if scroll behavior is supported and polyfill is not forced\n    if (\n      'scrollBehavior' in d.documentElement.style &&\n      w.__forceSmoothScrollPolyfill__ !== true\n    ) {\n      return;\n    }\n\n    // globals\n    var Element = w.HTMLElement || w.Element;\n    var SCROLL_TIME = 468;\n\n    // object gathering original scroll methods\n    var original = {\n      scroll: w.scroll || w.scrollTo,\n      scrollBy: w.scrollBy,\n      elementScroll: Element.prototype.scroll || scrollElement,\n      scrollIntoView: Element.prototype.scrollIntoView\n    };\n\n    // define timing method\n    var now =\n      w.performance && w.performance.now\n        ? w.performance.now.bind(w.performance)\n        : Date.now;\n\n    /**\n     * indicates if a the current browser is made by Microsoft\n     * @method isMicrosoftBrowser\n     * @param {String} userAgent\n     * @returns {Boolean}\n     */\n    function isMicrosoftBrowser(userAgent) {\n      var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n\n      return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n    }\n\n    /*\n     * IE has rounding bug rounding down clientHeight and clientWidth and\n     * rounding up scrollHeight and scrollWidth causing false positives\n     * on hasScrollableSpace\n     */\n    var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n\n    /**\n     * changes scroll position inside an element\n     * @method scrollElement\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */\n    function scrollElement(x, y) {\n      this.scrollLeft = x;\n      this.scrollTop = y;\n    }\n\n    /**\n     * returns result of applying ease math function to a number\n     * @method ease\n     * @param {Number} k\n     * @returns {Number}\n     */\n    function ease(k) {\n      return 0.5 * (1 - Math.cos(Math.PI * k));\n    }\n\n    /**\n     * indicates if a smooth behavior should be applied\n     * @method shouldBailOut\n     * @param {Number|Object} firstArg\n     * @returns {Boolean}\n     */\n    function shouldBailOut(firstArg) {\n      if (\n        firstArg === null ||\n        typeof firstArg !== 'object' ||\n        firstArg.behavior === undefined ||\n        firstArg.behavior === 'auto' ||\n        firstArg.behavior === 'instant'\n      ) {\n        // first argument is not an object/null\n        // or behavior is auto, instant or undefined\n        return true;\n      }\n\n      if (typeof firstArg === 'object' && firstArg.behavior === 'smooth') {\n        // first argument is an object and behavior is smooth\n        return false;\n      }\n\n      // throw error when behavior is not supported\n      throw new TypeError(\n        'behavior member of ScrollOptions ' +\n          firstArg.behavior +\n          ' is not a valid value for enumeration ScrollBehavior.'\n      );\n    }\n\n    /**\n     * indicates if an element has scrollable space in the provided axis\n     * @method hasScrollableSpace\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function hasScrollableSpace(el, axis) {\n      if (axis === 'Y') {\n        return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n      }\n\n      if (axis === 'X') {\n        return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n      }\n    }\n\n    /**\n     * indicates if an element has a scrollable overflow property in the axis\n     * @method canOverflow\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function canOverflow(el, axis) {\n      var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n\n      return overflowValue === 'auto' || overflowValue === 'scroll';\n    }\n\n    /**\n     * indicates if an element can be scrolled in either axis\n     * @method isScrollable\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function isScrollable(el) {\n      var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n      var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n\n      return isScrollableY || isScrollableX;\n    }\n\n    /**\n     * finds scrollable parent of an element\n     * @method findScrollableParent\n     * @param {Node} el\n     * @returns {Node} el\n     */\n    function findScrollableParent(el) {\n      while (el !== d.body && isScrollable(el) === false) {\n        el = el.parentNode || el.host;\n      }\n\n      return el;\n    }\n\n    /**\n     * self invoked function that, given a context, steps through scrolling\n     * @method step\n     * @param {Object} context\n     * @returns {undefined}\n     */\n    function step(context) {\n      var time = now();\n      var value;\n      var currentX;\n      var currentY;\n      var elapsed = (time - context.startTime) / SCROLL_TIME;\n\n      // avoid elapsed times higher than one\n      elapsed = elapsed > 1 ? 1 : elapsed;\n\n      // apply easing to elapsed time\n      value = ease(elapsed);\n\n      currentX = context.startX + (context.x - context.startX) * value;\n      currentY = context.startY + (context.y - context.startY) * value;\n\n      context.method.call(context.scrollable, currentX, currentY);\n\n      // scroll more if we have not reached our destination\n      if (currentX !== context.x || currentY !== context.y) {\n        w.requestAnimationFrame(step.bind(w, context));\n      }\n    }\n\n    /**\n     * scrolls window or element with a smooth behavior\n     * @method smoothScroll\n     * @param {Object|Node} el\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */\n    function smoothScroll(el, x, y) {\n      var scrollable;\n      var startX;\n      var startY;\n      var method;\n      var startTime = now();\n\n      // define scroll context\n      if (el === d.body) {\n        scrollable = w;\n        startX = w.scrollX || w.pageXOffset;\n        startY = w.scrollY || w.pageYOffset;\n        method = original.scroll;\n      } else {\n        scrollable = el;\n        startX = el.scrollLeft;\n        startY = el.scrollTop;\n        method = scrollElement;\n      }\n\n      // scroll looping over a frame\n      step({\n        scrollable: scrollable,\n        method: method,\n        startTime: startTime,\n        startX: startX,\n        startY: startY,\n        x: x,\n        y: y\n      });\n    }\n\n    // ORIGINAL METHODS OVERRIDES\n    // w.scroll and w.scrollTo\n    w.scroll = w.scrollTo = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.scroll.call(\n          w,\n          arguments[0].left !== undefined\n            ? arguments[0].left\n            : typeof arguments[0] !== 'object'\n              ? arguments[0]\n              : w.scrollX || w.pageXOffset,\n          // use top prop, second argument if present or fallback to scrollY\n          arguments[0].top !== undefined\n            ? arguments[0].top\n            : arguments[1] !== undefined\n              ? arguments[1]\n              : w.scrollY || w.pageYOffset\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        arguments[0].left !== undefined\n          ? ~~arguments[0].left\n          : w.scrollX || w.pageXOffset,\n        arguments[0].top !== undefined\n          ? ~~arguments[0].top\n          : w.scrollY || w.pageYOffset\n      );\n    };\n\n    // w.scrollBy\n    w.scrollBy = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0])) {\n        original.scrollBy.call(\n          w,\n          arguments[0].left !== undefined\n            ? arguments[0].left\n            : typeof arguments[0] !== 'object' ? arguments[0] : 0,\n          arguments[0].top !== undefined\n            ? arguments[0].top\n            : arguments[1] !== undefined ? arguments[1] : 0\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        ~~arguments[0].left + (w.scrollX || w.pageXOffset),\n        ~~arguments[0].top + (w.scrollY || w.pageYOffset)\n      );\n    };\n\n    // Element.prototype.scroll and Element.prototype.scrollTo\n    Element.prototype.scroll = Element.prototype.scrollTo = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        // if one number is passed, throw error to match Firefox implementation\n        if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n          throw new SyntaxError('Value could not be converted');\n        }\n\n        original.elementScroll.call(\n          this,\n          // use left prop, first number argument or fallback to scrollLeft\n          arguments[0].left !== undefined\n            ? ~~arguments[0].left\n            : typeof arguments[0] !== 'object' ? ~~arguments[0] : this.scrollLeft,\n          // use top prop, second argument or fallback to scrollTop\n          arguments[0].top !== undefined\n            ? ~~arguments[0].top\n            : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop\n        );\n\n        return;\n      }\n\n      var left = arguments[0].left;\n      var top = arguments[0].top;\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        this,\n        this,\n        typeof left === 'undefined' ? this.scrollLeft : ~~left,\n        typeof top === 'undefined' ? this.scrollTop : ~~top\n      );\n    };\n\n    // Element.prototype.scrollBy\n    Element.prototype.scrollBy = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.elementScroll.call(\n          this,\n          arguments[0].left !== undefined\n            ? ~~arguments[0].left + this.scrollLeft\n            : ~~arguments[0] + this.scrollLeft,\n          arguments[0].top !== undefined\n            ? ~~arguments[0].top + this.scrollTop\n            : ~~arguments[1] + this.scrollTop\n        );\n\n        return;\n      }\n\n      this.scroll({\n        left: ~~arguments[0].left + this.scrollLeft,\n        top: ~~arguments[0].top + this.scrollTop,\n        behavior: arguments[0].behavior\n      });\n    };\n\n    // Element.prototype.scrollIntoView\n    Element.prototype.scrollIntoView = function() {\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.scrollIntoView.call(\n          this,\n          arguments[0] === undefined ? true : arguments[0]\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      var scrollableParent = findScrollableParent(this);\n      var parentRects = scrollableParent.getBoundingClientRect();\n      var clientRects = this.getBoundingClientRect();\n\n      if (scrollableParent !== d.body) {\n        // reveal element inside parent\n        smoothScroll.call(\n          this,\n          scrollableParent,\n          scrollableParent.scrollLeft + clientRects.left - parentRects.left,\n          scrollableParent.scrollTop + clientRects.top - parentRects.top\n        );\n\n        // reveal parent in viewport unless is fixed\n        if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n          w.scrollBy({\n            left: parentRects.left,\n            top: parentRects.top,\n            behavior: 'smooth'\n          });\n        }\n      } else {\n        // reveal element in viewport\n        w.scrollBy({\n          left: clientRects.left,\n          top: clientRects.top,\n          behavior: 'smooth'\n        });\n      }\n    };\n  }\n\n  if (typeof exports === 'object' && typeof module !== 'undefined') {\n    // commonjs\n    module.exports = { polyfill: polyfill };\n  } else {\n    // global\n    polyfill();\n  }\n\n}());\n","const rootObj = { __sap_ES_MODULE__: true };\n(function() {\n  // @ts-check\r\n\r\n/** @license MIT smoothscroll-anchor-polyfill 1.3.2 (c) 2020 Jonas Kuske */\r\n\r\nvar _DEBUG_ = true; // removed during minification\r\n\r\n(function(/** @type {any} */ root, factory) {\r\n  var isESModule = root && root.__sap_ES_MODULE__\r\n  // @ts-ignore\r\n  if (!isESModule && typeof define === 'function' && define.amd) define([], factory);\r\n  else if (!isESModule && typeof module === 'object' && module.exports) module.exports = factory();\r\n  else root.SmoothscrollAnchorPolyfill = factory();\r\n})(this, function() {\r\n  function SmoothscrollAnchorPolyfill() {\r\n    var instance = this, isBrowser = typeof window !== 'undefined';\r\n\r\n    if (isBrowser) {\r\n      /**\r\n       * Add flag to Window interface, workaround for type check\r\n       * @typedef {{__forceSmoothscrollAnchorPolyfill__: [boolean]}} GlobalFlag @deprecated\r\n       * @typedef {typeof globalThis & Window & GlobalFlag} WindowWithFlag\r\n       * @type {WindowWithFlag} */\r\n      var w = (window), d = document, docEl = d.documentElement, dummy = d.createElement('a');\r\n    }\r\n\r\n    /**\r\n     * Starts the polyfill by attaching the neccessary EventListeners\r\n     *\r\n     * Aborts, if ('scrollBehavior' in documentElement.style) and the force flag\r\n     * isn't set on the options parameter Object or globally on window\r\n     * @param {PolyfillOptions} [opts] Options for invoking the polyfill\r\n     * @returns {SmoothscrollAnchorPolyfill} Polyfill Instance, allows for chaining\r\n     *\r\n     * @typedef {Object} PolyfillOptions\r\n     * @prop {boolean} [force] Enable despite native support, overrides global flag\r\n     */\r\n    this.polyfill = function(opts) {\r\n      opts = opts || {};\r\n      if (isBrowser) {\r\n        /** @deprecated */\r\n        var globalFlag = w.__forceSmoothscrollAnchorPolyfill__;\r\n        var force = typeof opts.force === 'boolean' ? opts.force : globalFlag;\r\n\r\n        // Abort if smoothscroll has native support and force flag isn't set\r\n        if ('scrollBehavior' in dummy.style && !force) return instance;\r\n\r\n        instance.destroy(); // Remove previous listeners\r\n        d.addEventListener('click', handleClick, false);\r\n        d.addEventListener('scroll', trackScrollPositions);\r\n        w.addEventListener('hashchange', handleHashChange);\r\n      }\r\n      return instance;\r\n    };\r\n\r\n    /**\r\n     * Stops the polyfill by removing all EventListeners\r\n     * @returns {SmoothscrollAnchorPolyfill} Polyfill Instance, allows for chaining\r\n     * @param {DestroyOptions} [opts] Options for destroying the polyfill\r\n     *\r\n     * @typedef {Object} DestroyOptions\r\n     * @prop {HTMLAnchorElement} [_dummy] DON'T USE THIS. INTERNAL USE ONLY.\r\n     */\r\n    this.destroy = function(opts) {\r\n      opts = opts || {};\r\n      // For testing purposes only: support injection of external dummy element\r\n      // Allows controlling whether env is treated as env with native support\r\n      if (_DEBUG_ && opts._dummy) dummy = opts._dummy;\r\n\r\n      if (isBrowser) {\r\n        d.removeEventListener('click', handleClick, false);\r\n        d.removeEventListener('scroll', trackScrollPositions);\r\n        w.removeEventListener('hashchange', handleHashChange);\r\n      }\r\n      return instance;\r\n    };\r\n\r\n    if (!isBrowser) return;\r\n\r\n    // Check if browser supports focus without automatic scrolling (preventScroll)\r\n    var supportsPreventScroll = false;\r\n    try {\r\n      // Define getter for preventScroll to find out if the browser accesses it\r\n      var preppedFocusOption = Object.defineProperty({}, 'preventScroll', {\r\n        get: function() {\r\n          supportsPreventScroll = true;\r\n        }\r\n      });\r\n      // Trigger focus – if browser uses preventScroll the var will be set to true\r\n      dummy.focus(preppedFocusOption);\r\n    } catch (e) { }\r\n\r\n    // Regex to extract the value following the scroll-behavior property name\r\n    var extractValue = /scroll-behavior:[\\s]*([^;\"`'\\s]+)/;\r\n    var docElStyle = getComputedStyle(docEl)\r\n\r\n    /**\r\n     * Returns true if scroll-behavior: smooth is set and not overwritten\r\n     * by a higher-specifity declaration, else returns false\r\n     */\r\n    function shouldSmoothscroll() {\r\n      // Values to check for set scroll-behavior in order of priority/specificity\r\n      var valuesToCheck = [\r\n        // Priority 1: behavior assigned to style property\r\n        // Allows toggling smoothscroll from JS (docEl.style.scrollBehavior = ...)\r\n        docEl.style.scrollBehavior,\r\n        // Priority 2: behavior specified inline in style attribute\r\n        (extractValue.exec(docEl.getAttribute('style')) || [])[1],\r\n        // Priority 3: custom property\r\n        // Behaves like regular CSS, e.g. allows using media queries\r\n        docElStyle.getPropertyValue('--scroll-behavior'),\r\n        // Priority 4: behavior specified in fontFamily\r\n        // Same use case as priority 3, but supports legacy browsers without CSS vars\r\n        (extractValue.exec(docElStyle.fontFamily) || [])[1]\r\n      ];\r\n\r\n      // Loop over values in specified order, return once a valid value is found\r\n      for (var i = 0; i < valuesToCheck.length; i++) {\r\n        var specifiedBehavior = getScrollBehavior(valuesToCheck[i]);\r\n        if (specifiedBehavior !== null) return specifiedBehavior;\r\n      }\r\n      // No value found? Return false, no set value = no smoothscroll :(\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * If a valid CSS property value for scroll-behavior is passed, returns\r\n     * whether it specifies smooth scroll behavior or not, else returns null\r\n     * @param {?string} value The value to check\r\n     * @returns {?boolean} The specified scroll behavior or null\r\n     */\r\n    function getScrollBehavior(value) {\r\n      var status = null;\r\n      value = value && value.trim();\r\n      if (/^smooth$/.test(value)) status = true;\r\n      if (/^(initial|inherit|auto|unset)$/.test(value)) status = false;\r\n      return status;\r\n    }\r\n\r\n    /**\r\n     * Get the target element of an event\r\n     * @param {Event} evt\r\n     * @returns {HTMLElement}\r\n     */\r\n    function getEventTarget(evt) {\r\n      evt = evt || w.event;\r\n      return /** @type {HTMLElement} */ (evt.target || evt.srcElement);\r\n    }\r\n\r\n    /**\r\n     * Check if an element is an anchor pointing to a target on the current page\r\n     * @param {HTMLAnchorElement} el\r\n     * @returns {boolean}\r\n     */\r\n    function isAnchorToLocalElement(el) {\r\n      // False if element isn't \"a\" or href has no #fragment\r\n      if (!/^a$/i.test(el.tagName) || !/#/.test(el.href)) return false;\r\n\r\n      // Fix bug in IE9 where anchor.pathname misses leading slash\r\n      var anchorPath = el.pathname;\r\n      if (anchorPath[0] !== '/') anchorPath = '/' + anchorPath;\r\n\r\n      // False if target isn't current page\r\n      if (el.hostname !== location.hostname || anchorPath !== location.pathname) return false;\r\n\r\n      // False if anchor targets a ?query that is different from the current one\r\n      // e.g. /?page=1 → /?page=2#content\r\n      if (el.search && el.search !== location.search) return false;\r\n\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Focuses an element, if it's not focused after the first try,\r\n     * allow focusing by adjusting tabIndex and retry\r\n     * @param {HTMLElement} el\r\n     */\r\n    function focusElement(el) {\r\n      el.focus({ preventScroll: true });\r\n      if (d.activeElement !== el) {\r\n        var prevTabIndex = el.getAttribute('tabindex');\r\n        el.setAttribute('tabindex', '-1');\r\n\r\n        if (getComputedStyle(el).outlineStyle === 'none') {\r\n          var prevOutline = el.style.outlineStyle;\r\n          el.style.outlineStyle = 'none';\r\n          el.addEventListener('blur', function undoOutlineChange() {\r\n            el.style.outlineStyle = prevOutline;\r\n            el.setAttribute('tabindex', prevTabIndex);\r\n            el.removeEventListener('blur', undoOutlineChange);\r\n          })\r\n        }\r\n\r\n        el.focus({ preventScroll: true });\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Returns the element whose id matches the hash or\r\n     * document.body if the hash is \"#top\" or \"\" (empty string)\r\n     * @param {string} hash\r\n     */\r\n    function getScrollTarget(hash) {\r\n      if (typeof hash !== 'string') return null;\r\n      hash = decodeHash(hash);\r\n\r\n      // Retrieve target if an id is specified in the hash, otherwise use body.\r\n      // If hash is \"#top\" and no target with id \"top\" was found, also use body\r\n      // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-href\r\n      var target = hash ? d.getElementById(hash.slice(1)) : d.body;\r\n      if (hash === '#top' && !target) target = d.body;\r\n      return target;\r\n    }\r\n\r\n    /**\r\n     * Takes a URL-encoded hash and returns the decoded version.\r\n     * @param {string} hash Hash to decode\r\n     */\r\n    function decodeHash(hash) {\r\n      try {\r\n        // \"#%F0%9F%91%8D%F0%9F%8F%BB\" -> \"#👍🏻\"\r\n        hash = decodeURIComponent(hash);\r\n      } catch (e) { /* */ }\r\n      return hash;\r\n    }\r\n\r\n    /**\r\n     * Walks up the DOM starting from \"element\" until an element satisfies \"validate()\"\r\n     * @param {HTMLElement} element The element from where to start validating\r\n     * @param {function} validate Validation function, receives current element as arg\r\n     * @returns {?HTMLElement} The found element or null\r\n     */\r\n    function findInParents(element, validate) {\r\n      if (validate(element)) return element;\r\n      if (element.parentElement) return findInParents(element.parentElement, validate);\r\n      return null;\r\n    }\r\n\r\n    // Stores the setTimeout id of pending focus changes, allows aborting them\r\n    var pendingFocusChange;\r\n\r\n    /**\r\n     * Scrolls to a given element or to the top if the given element\r\n     * is document.body, then focuses the element\r\n     * @param {HTMLElement} target\r\n     */\r\n    function triggerSmoothscroll(target) {\r\n      // Clear potential pending focus change triggered by a previous scroll\r\n      if (!supportsPreventScroll) clearTimeout(pendingFocusChange);\r\n\r\n      // Use JS scroll APIs to scroll to top (if target is body) or to the element\r\n      // This allows polyfills for these APIs to do their smooth scrolling magic\r\n      var scrollTop = target === d.body;\r\n      if (scrollTop) w.scroll({ top: 0, left: 0, behavior: 'smooth' });\r\n      else target.scrollIntoView({ behavior: 'smooth', block: 'start' });\r\n\r\n      // If the browser supports preventScroll: immediately focus the target\r\n      // Otherwise schedule the focus so the smoothscroll isn't interrupted\r\n      if (supportsPreventScroll) focusElement(target);\r\n      else pendingFocusChange = setTimeout(focusElement.bind(null, target), 450);\r\n    }\r\n\r\n    /**\r\n     * Check if the clicked target is an anchor pointing to a local element,\r\n     * if so prevent the default behavior and handle the scrolling using the\r\n     * native JavaScript scroll APIs so smoothscroll polyfills apply\r\n     * @param {MouseEvent} evt\r\n     */\r\n    function handleClick(evt) {\r\n      var notPrimaryClick = evt.metaKey || evt.ctrlKey || evt.shiftKey || evt.button !== 0;\r\n      if (evt.defaultPrevented || notPrimaryClick) return;\r\n\r\n      // scroll-behavior not set to smooth? Bail out, let browser handle it\r\n      if (!shouldSmoothscroll()) return;\r\n\r\n      // Check the DOM from the click target upwards if a local anchor was clicked\r\n      var anchor = /** @type {?HTMLAnchorElement} */ (\r\n        findInParents(getEventTarget(evt), isAnchorToLocalElement)\r\n      );\r\n      if (!anchor) return;\r\n\r\n      // Find the element targeted by the hash\r\n      var hash = anchor.hash;\r\n      var target = getScrollTarget(hash);\r\n\r\n      if (target) {\r\n        // Prevent default browser behavior to avoid a jump to the anchor target\r\n        evt.preventDefault();\r\n\r\n        // Trigger the smooth scroll\r\n        triggerSmoothscroll(target);\r\n\r\n        // Append the hash to the URL\r\n        if (history.pushState) history.pushState(null, d.title, (hash || '#'));\r\n      }\r\n    }\r\n\r\n    // To enable smooth scrolling on hashchange, we need to immediately restore\r\n    // the scroll pos after a hashchange changed it, so we track it constantly.\r\n    // Some browsers don't trigger a scroll event before the hashchange,\r\n    // so to undo, the position from last scroll is the one we need to go back to.\r\n    // In others (e.g. IE) the scroll listener is triggered again before the\r\n    // hashchange occurs and the last reported position is already the new one\r\n    // updated by the hashchange – we need the second last to undo there.\r\n    // Because of this we don't track just the last, but the last two positions.\r\n    var lastTwoScrollPos = [];\r\n\r\n    /**\r\n      * Tries to undo the automatic, instant scroll caused by a hashchange\r\n      * and instead scrolls smoothly to the new hash target\r\n      */\r\n    function handleHashChange() {\r\n      // scroll-behavior not set to smooth or body not parsed yet? Abort\r\n      if (!d.body || !shouldSmoothscroll()) return;\r\n\r\n      var target = getScrollTarget(location.hash);\r\n      if (!target) return;\r\n\r\n      // If the position last reported by the scroll listener is the same as the\r\n      // current one caused by a hashchange, go back to second last – else last\r\n      var currentPos = getScrollTop();\r\n      var top = lastTwoScrollPos[lastTwoScrollPos[1] === currentPos ? 0 : 1];\r\n\r\n      // @ts-ignore\r\n      // Undo the scroll caused by the hashchange...\r\n      // Using {behavior: 'instant'} even though it's not in the spec anymore as\r\n      // Blink & Gecko support it – once an engine with native support doesn't,\r\n      // we need to disable scroll-behavior during scroll reset, then restore\r\n      w.scroll({ top: top, behavior: 'instant' });\r\n      // ...and instead smoothscroll to the target\r\n      triggerSmoothscroll(target);\r\n    }\r\n\r\n    /**\r\n     * Returns the scroll offset towards the top\r\n     */\r\n    function getScrollTop() {\r\n      return docEl.scrollTop || d.body.scrollTop;\r\n    }\r\n\r\n    /**\r\n     * Update the last two scroll positions\r\n     */\r\n    function trackScrollPositions() {\r\n      if (!d.body) return; // Body not parsed yet? Abort\r\n      lastTwoScrollPos[0] = lastTwoScrollPos[1];\r\n      lastTwoScrollPos[1] = getScrollTop();\r\n    }\r\n  }\r\n\r\n  return new SmoothscrollAnchorPolyfill().polyfill();\r\n});\r\n\n}).call(rootObj);\n\nconst { SmoothscrollAnchorPolyfill } = rootObj;\nconst { destroy, polyfill } = SmoothscrollAnchorPolyfill;\n\nexport { destroy, polyfill };\nexport default SmoothscrollAnchorPolyfill;"]}