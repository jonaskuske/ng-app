{"version":3,"sources":["smoothscroll-es5.47f878f2df631b66c025.js","webpack:///node_modules/smoothscroll-polyfill/dist/smoothscroll.js","webpack:///node_modules/smoothscroll-anchor-polyfill/dist/index.mjs"],"names":["window","webpackJsonp","push","dwco","module","exports","__webpack_require__","polyfill","w","d","document","documentElement","style","__forceSmoothScrollPolyfill__","userAgent","Element","HTMLElement","SCROLL_TIME","original","scroll","scrollTo","scrollBy","elementScroll","prototype","scrollElement","scrollIntoView","now","performance","bind","Date","ROUNDING_TOLERANCE","navigator","RegExp","join","test","arguments","shouldBailOut","smoothScroll","call","body","left","scrollX","pageXOffset","top","scrollY","pageYOffset","this","scrollLeft","scrollTop","SyntaxError","behavior","scrollableParent","findScrollableParent","parentRects","getBoundingClientRect","clientRects","getComputedStyle","position","x","y","firstArg","TypeError","hasScrollableSpace","el","axis","clientHeight","scrollHeight","clientWidth","scrollWidth","canOverflow","overflowValue","isScrollable","isScrollableY","isScrollableX","parentNode","host","scrollable","startX","startY","method","startTime","step","context","value","currentX","currentY","elapsed","Math","cos","PI","requestAnimationFrame","r","__webpack_exports__","destroy","rootObj","__sap_ES_MODULE__","factory","isESModule","instance","isBrowser","docEl","dummy","createElement","opts","force","__forceSmoothscrollAnchorPolyfill__","addEventListener","handleClick","trackScrollPositions","handleHashChange","_dummy","removeEventListener","supportsPreventScroll","preppedFocusOption","Object","defineProperty","get","focus","e","pendingFocusChange","extractValue","docElStyle","lastTwoScrollPos","shouldSmoothscroll","valuesToCheck","scrollBehavior","exec","getAttribute","getPropertyValue","fontFamily","i","length","specifiedBehavior","status","trim","isAnchorToLocalElement","tagName","href","anchorPath","pathname","hostname","location","focusElement","preventScroll","activeElement","prevTabIndex","setAttribute","outlineStyle","prevOutline","undoOutlineChange","getScrollTarget","hash","target","decodeURIComponent","getElementById","slice","triggerSmoothscroll","clearTimeout","block","setTimeout","evt","metaKey","ctrlKey","shiftKey","button","anchor","findInParents","element","validate","parentElement","event","srcElement","preventDefault","history","pushState","title","currentPos","getScrollTop","define","amd","SmoothscrollAnchorPolyfill","default"],"mappings":"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","file":"smoothscroll-es5.47f878f2df631b66c025.js","sourcesContent":["(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{dwco:function(module,exports,__webpack_require__){!function(){\"use strict\";module.exports={polyfill:function(){var w=window,d=document;if(!(\"scrollBehavior\"in d.documentElement.style&&!0!==w.__forceSmoothScrollPolyfill__)){var userAgent,Element=w.HTMLElement||w.Element,SCROLL_TIME=468,original={scroll:w.scroll||w.scrollTo,scrollBy:w.scrollBy,elementScroll:Element.prototype.scroll||scrollElement,scrollIntoView:Element.prototype.scrollIntoView},now=w.performance&&w.performance.now?w.performance.now.bind(w.performance):Date.now,ROUNDING_TOLERANCE=(userAgent=w.navigator.userAgent,new RegExp([\"MSIE \",\"Trident/\",\"Edge/\"].join(\"|\")).test(userAgent)?1:0);w.scroll=w.scrollTo=function(){void 0!==arguments[0]&&(!0!==shouldBailOut(arguments[0])?smoothScroll.call(w,d.body,void 0!==arguments[0].left?~~arguments[0].left:w.scrollX||w.pageXOffset,void 0!==arguments[0].top?~~arguments[0].top:w.scrollY||w.pageYOffset):original.scroll.call(w,void 0!==arguments[0].left?arguments[0].left:\"object\"!=typeof arguments[0]?arguments[0]:w.scrollX||w.pageXOffset,void 0!==arguments[0].top?arguments[0].top:void 0!==arguments[1]?arguments[1]:w.scrollY||w.pageYOffset))},w.scrollBy=function(){void 0!==arguments[0]&&(shouldBailOut(arguments[0])?original.scrollBy.call(w,void 0!==arguments[0].left?arguments[0].left:\"object\"!=typeof arguments[0]?arguments[0]:0,void 0!==arguments[0].top?arguments[0].top:void 0!==arguments[1]?arguments[1]:0):smoothScroll.call(w,d.body,~~arguments[0].left+(w.scrollX||w.pageXOffset),~~arguments[0].top+(w.scrollY||w.pageYOffset)))},Element.prototype.scroll=Element.prototype.scrollTo=function(){if(void 0!==arguments[0])if(!0!==shouldBailOut(arguments[0])){var left=arguments[0].left,top=arguments[0].top;smoothScroll.call(this,this,void 0===left?this.scrollLeft:~~left,void 0===top?this.scrollTop:~~top)}else{if(\"number\"==typeof arguments[0]&&void 0===arguments[1])throw new SyntaxError(\"Value could not be converted\");original.elementScroll.call(this,void 0!==arguments[0].left?~~arguments[0].left:\"object\"!=typeof arguments[0]?~~arguments[0]:this.scrollLeft,void 0!==arguments[0].top?~~arguments[0].top:void 0!==arguments[1]?~~arguments[1]:this.scrollTop)}},Element.prototype.scrollBy=function(){void 0!==arguments[0]&&(!0!==shouldBailOut(arguments[0])?this.scroll({left:~~arguments[0].left+this.scrollLeft,top:~~arguments[0].top+this.scrollTop,behavior:arguments[0].behavior}):original.elementScroll.call(this,void 0!==arguments[0].left?~~arguments[0].left+this.scrollLeft:~~arguments[0]+this.scrollLeft,void 0!==arguments[0].top?~~arguments[0].top+this.scrollTop:~~arguments[1]+this.scrollTop))},Element.prototype.scrollIntoView=function(){if(!0!==shouldBailOut(arguments[0])){var scrollableParent=findScrollableParent(this),parentRects=scrollableParent.getBoundingClientRect(),clientRects=this.getBoundingClientRect();scrollableParent!==d.body?(smoothScroll.call(this,scrollableParent,scrollableParent.scrollLeft+clientRects.left-parentRects.left,scrollableParent.scrollTop+clientRects.top-parentRects.top),\"fixed\"!==w.getComputedStyle(scrollableParent).position&&w.scrollBy({left:parentRects.left,top:parentRects.top,behavior:\"smooth\"})):w.scrollBy({left:clientRects.left,top:clientRects.top,behavior:\"smooth\"})}else original.scrollIntoView.call(this,void 0===arguments[0]||arguments[0])}}function scrollElement(x,y){this.scrollLeft=x,this.scrollTop=y}function shouldBailOut(firstArg){if(null===firstArg||\"object\"!=typeof firstArg||void 0===firstArg.behavior||\"auto\"===firstArg.behavior||\"instant\"===firstArg.behavior)return!0;if(\"object\"==typeof firstArg&&\"smooth\"===firstArg.behavior)return!1;throw new TypeError(\"behavior member of ScrollOptions \"+firstArg.behavior+\" is not a valid value for enumeration ScrollBehavior.\")}function hasScrollableSpace(el,axis){return\"Y\"===axis?el.clientHeight+ROUNDING_TOLERANCE<el.scrollHeight:\"X\"===axis?el.clientWidth+ROUNDING_TOLERANCE<el.scrollWidth:void 0}function canOverflow(el,axis){var overflowValue=w.getComputedStyle(el,null)[\"overflow\"+axis];return\"auto\"===overflowValue||\"scroll\"===overflowValue}function isScrollable(el){var isScrollableY=hasScrollableSpace(el,\"Y\")&&canOverflow(el,\"Y\"),isScrollableX=hasScrollableSpace(el,\"X\")&&canOverflow(el,\"X\");return isScrollableY||isScrollableX}function findScrollableParent(el){for(;el!==d.body&&!1===isScrollable(el);)el=el.parentNode||el.host;return el}function smoothScroll(el,x,y){var scrollable,startX,startY,method,startTime=now();el===d.body?(scrollable=w,startX=w.scrollX||w.pageXOffset,startY=w.scrollY||w.pageYOffset,method=original.scroll):(scrollable=el,startX=el.scrollLeft,startY=el.scrollTop,method=scrollElement),function step(context){var value,currentX,currentY,elapsed=(now()-context.startTime)/SCROLL_TIME;elapsed=elapsed>1?1:elapsed,value=.5*(1-Math.cos(Math.PI*elapsed)),context.method.call(context.scrollable,currentX=context.startX+(context.x-context.startX)*value,currentY=context.startY+(context.y-context.startY)*value),currentX===context.x&&currentY===context.y||w.requestAnimationFrame(step.bind(w,context))}({scrollable:scrollable,method:method,startTime:startTime,startX:startX,startY:startY,x:x,y:y})}}}}()},e5dI:function(__webpack_module__,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,\"destroy\",(function(){return destroy})),__webpack_require__.d(__webpack_exports__,\"polyfill\",(function(){return polyfill}));const rootObj={__sap_ES_MODULE__:!0};(function(){var factory,isESModule;factory=function(){return(new function(){var instance=this,isBrowser=\"undefined\"!=typeof window;if(isBrowser)var w=window,d=document,docEl=d.documentElement,dummy=d.createElement(\"a\");if(this.polyfill=function(opts){if(opts=opts||{},isBrowser){if(\"scrollBehavior\"in dummy.style&&!(\"boolean\"==typeof opts.force?opts.force:w.__forceSmoothscrollAnchorPolyfill__))return instance;instance.destroy(),d.addEventListener(\"click\",handleClick,!1),d.addEventListener(\"scroll\",trackScrollPositions),w.addEventListener(\"hashchange\",handleHashChange)}return instance},this.destroy=function(opts){return(opts=opts||{})._dummy&&(dummy=opts._dummy),isBrowser&&(d.removeEventListener(\"click\",handleClick,!1),d.removeEventListener(\"scroll\",trackScrollPositions),w.removeEventListener(\"hashchange\",handleHashChange)),instance},isBrowser){var supportsPreventScroll=!1;try{var preppedFocusOption=Object.defineProperty({},\"preventScroll\",{get:function(){supportsPreventScroll=!0}});dummy.focus(preppedFocusOption)}catch(e){}var pendingFocusChange,extractValue=/scroll-behavior:[\\s]*([^;\"`'\\s]+)/,docElStyle=getComputedStyle(docEl),lastTwoScrollPos=[]}function shouldSmoothscroll(){for(var valuesToCheck=[docEl.style.scrollBehavior,(extractValue.exec(docEl.getAttribute(\"style\"))||[])[1],docElStyle.getPropertyValue(\"--scroll-behavior\"),(extractValue.exec(docElStyle.fontFamily)||[])[1]],i=0;i<valuesToCheck.length;i++){var specifiedBehavior=(status=void 0,status=null,value=(value=valuesToCheck[i])&&value.trim(),/^smooth$/.test(value)&&(status=!0),/^(initial|inherit|auto|unset)$/.test(value)&&(status=!1),status);if(null!==specifiedBehavior)return specifiedBehavior}var value,status;return!1}function isAnchorToLocalElement(el){if(!/^a$/i.test(el.tagName)||!/#/.test(el.href))return!1;var anchorPath=el.pathname;return\"/\"!==anchorPath[0]&&(anchorPath=\"/\"+anchorPath),el.hostname===location.hostname&&anchorPath===location.pathname}function focusElement(el){if(el.focus({preventScroll:!0}),d.activeElement!==el){var prevTabIndex=el.getAttribute(\"tabindex\");if(el.setAttribute(\"tabindex\",\"-1\"),\"none\"===getComputedStyle(el).outlineStyle){var prevOutline=el.style.outlineStyle;el.style.outlineStyle=\"none\",el.addEventListener(\"blur\",(function undoOutlineChange(){el.style.outlineStyle=prevOutline,el.setAttribute(\"tabindex\",prevTabIndex),el.removeEventListener(\"blur\",undoOutlineChange)}))}el.focus({preventScroll:!0})}}function getScrollTarget(hash){if(\"string\"!=typeof hash)return null;var target=(hash=function(hash){try{hash=decodeURIComponent(hash)}catch(e){}return hash}(hash))?d.getElementById(hash.slice(1)):d.body;return\"#top\"!==hash||target||(target=d.body),target}function triggerSmoothscroll(target){supportsPreventScroll||clearTimeout(pendingFocusChange),target===d.body?w.scroll({top:0,left:0,behavior:\"smooth\"}):target.scrollIntoView({behavior:\"smooth\",block:\"start\"}),supportsPreventScroll?focusElement(target):pendingFocusChange=setTimeout(focusElement.bind(null,target),450)}function handleClick(evt){if(!(evt.metaKey||evt.ctrlKey||evt.shiftKey||0!==evt.button)&&shouldSmoothscroll()){var anchor=function findInParents(element,validate){return validate(element)?element:element.parentElement?findInParents(element.parentElement,validate):null}(function(evt){return(evt=evt||w.event).target||evt.srcElement}(evt),isAnchorToLocalElement);if(anchor){var hash=anchor.hash,target=getScrollTarget(hash);target&&(evt.preventDefault(),triggerSmoothscroll(target),history.pushState&&history.pushState(null,d.title,hash||\"#\"))}}}function handleHashChange(){if(d.body&&shouldSmoothscroll()){var target=getScrollTarget(location.hash);if(target){var currentPos=getScrollTop();w.scroll({top:lastTwoScrollPos[lastTwoScrollPos[1]===currentPos?0:1],behavior:\"instant\"}),triggerSmoothscroll(target)}}}function getScrollTop(){return docEl.scrollTop||d.body.scrollTop}function trackScrollPositions(){d.body&&(lastTwoScrollPos[0]=lastTwoScrollPos[1],lastTwoScrollPos[1]=getScrollTop())}}).polyfill()},!(isESModule=this&&this.__sap_ES_MODULE__)&&\"function\"==typeof define&&define.amd?define([],factory):!isESModule&&\"object\"==typeof module&&module.exports?module.exports=factory():this.SmoothscrollAnchorPolyfill=factory()}).call(rootObj);const{SmoothscrollAnchorPolyfill:SmoothscrollAnchorPolyfill}=rootObj,{destroy:destroy,polyfill:polyfill}=SmoothscrollAnchorPolyfill;__webpack_exports__.default=SmoothscrollAnchorPolyfill}}]);\n//# sourceMappingURL=smoothscroll-es2015.47f878f2df631b66c025.js.map","/* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */\n(function () {\n  'use strict';\n\n  // polyfill\n  function polyfill() {\n    // aliases\n    var w = window;\n    var d = document;\n\n    // return if scroll behavior is supported and polyfill is not forced\n    if (\n      'scrollBehavior' in d.documentElement.style &&\n      w.__forceSmoothScrollPolyfill__ !== true\n    ) {\n      return;\n    }\n\n    // globals\n    var Element = w.HTMLElement || w.Element;\n    var SCROLL_TIME = 468;\n\n    // object gathering original scroll methods\n    var original = {\n      scroll: w.scroll || w.scrollTo,\n      scrollBy: w.scrollBy,\n      elementScroll: Element.prototype.scroll || scrollElement,\n      scrollIntoView: Element.prototype.scrollIntoView\n    };\n\n    // define timing method\n    var now =\n      w.performance && w.performance.now\n        ? w.performance.now.bind(w.performance)\n        : Date.now;\n\n    /**\n     * indicates if a the current browser is made by Microsoft\n     * @method isMicrosoftBrowser\n     * @param {String} userAgent\n     * @returns {Boolean}\n     */\n    function isMicrosoftBrowser(userAgent) {\n      var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n\n      return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n    }\n\n    /*\n     * IE has rounding bug rounding down clientHeight and clientWidth and\n     * rounding up scrollHeight and scrollWidth causing false positives\n     * on hasScrollableSpace\n     */\n    var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n\n    /**\n     * changes scroll position inside an element\n     * @method scrollElement\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */\n    function scrollElement(x, y) {\n      this.scrollLeft = x;\n      this.scrollTop = y;\n    }\n\n    /**\n     * returns result of applying ease math function to a number\n     * @method ease\n     * @param {Number} k\n     * @returns {Number}\n     */\n    function ease(k) {\n      return 0.5 * (1 - Math.cos(Math.PI * k));\n    }\n\n    /**\n     * indicates if a smooth behavior should be applied\n     * @method shouldBailOut\n     * @param {Number|Object} firstArg\n     * @returns {Boolean}\n     */\n    function shouldBailOut(firstArg) {\n      if (\n        firstArg === null ||\n        typeof firstArg !== 'object' ||\n        firstArg.behavior === undefined ||\n        firstArg.behavior === 'auto' ||\n        firstArg.behavior === 'instant'\n      ) {\n        // first argument is not an object/null\n        // or behavior is auto, instant or undefined\n        return true;\n      }\n\n      if (typeof firstArg === 'object' && firstArg.behavior === 'smooth') {\n        // first argument is an object and behavior is smooth\n        return false;\n      }\n\n      // throw error when behavior is not supported\n      throw new TypeError(\n        'behavior member of ScrollOptions ' +\n          firstArg.behavior +\n          ' is not a valid value for enumeration ScrollBehavior.'\n      );\n    }\n\n    /**\n     * indicates if an element has scrollable space in the provided axis\n     * @method hasScrollableSpace\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function hasScrollableSpace(el, axis) {\n      if (axis === 'Y') {\n        return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n      }\n\n      if (axis === 'X') {\n        return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n      }\n    }\n\n    /**\n     * indicates if an element has a scrollable overflow property in the axis\n     * @method canOverflow\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function canOverflow(el, axis) {\n      var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n\n      return overflowValue === 'auto' || overflowValue === 'scroll';\n    }\n\n    /**\n     * indicates if an element can be scrolled in either axis\n     * @method isScrollable\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function isScrollable(el) {\n      var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n      var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n\n      return isScrollableY || isScrollableX;\n    }\n\n    /**\n     * finds scrollable parent of an element\n     * @method findScrollableParent\n     * @param {Node} el\n     * @returns {Node} el\n     */\n    function findScrollableParent(el) {\n      while (el !== d.body && isScrollable(el) === false) {\n        el = el.parentNode || el.host;\n      }\n\n      return el;\n    }\n\n    /**\n     * self invoked function that, given a context, steps through scrolling\n     * @method step\n     * @param {Object} context\n     * @returns {undefined}\n     */\n    function step(context) {\n      var time = now();\n      var value;\n      var currentX;\n      var currentY;\n      var elapsed = (time - context.startTime) / SCROLL_TIME;\n\n      // avoid elapsed times higher than one\n      elapsed = elapsed > 1 ? 1 : elapsed;\n\n      // apply easing to elapsed time\n      value = ease(elapsed);\n\n      currentX = context.startX + (context.x - context.startX) * value;\n      currentY = context.startY + (context.y - context.startY) * value;\n\n      context.method.call(context.scrollable, currentX, currentY);\n\n      // scroll more if we have not reached our destination\n      if (currentX !== context.x || currentY !== context.y) {\n        w.requestAnimationFrame(step.bind(w, context));\n      }\n    }\n\n    /**\n     * scrolls window or element with a smooth behavior\n     * @method smoothScroll\n     * @param {Object|Node} el\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */\n    function smoothScroll(el, x, y) {\n      var scrollable;\n      var startX;\n      var startY;\n      var method;\n      var startTime = now();\n\n      // define scroll context\n      if (el === d.body) {\n        scrollable = w;\n        startX = w.scrollX || w.pageXOffset;\n        startY = w.scrollY || w.pageYOffset;\n        method = original.scroll;\n      } else {\n        scrollable = el;\n        startX = el.scrollLeft;\n        startY = el.scrollTop;\n        method = scrollElement;\n      }\n\n      // scroll looping over a frame\n      step({\n        scrollable: scrollable,\n        method: method,\n        startTime: startTime,\n        startX: startX,\n        startY: startY,\n        x: x,\n        y: y\n      });\n    }\n\n    // ORIGINAL METHODS OVERRIDES\n    // w.scroll and w.scrollTo\n    w.scroll = w.scrollTo = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.scroll.call(\n          w,\n          arguments[0].left !== undefined\n            ? arguments[0].left\n            : typeof arguments[0] !== 'object'\n              ? arguments[0]\n              : w.scrollX || w.pageXOffset,\n          // use top prop, second argument if present or fallback to scrollY\n          arguments[0].top !== undefined\n            ? arguments[0].top\n            : arguments[1] !== undefined\n              ? arguments[1]\n              : w.scrollY || w.pageYOffset\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        arguments[0].left !== undefined\n          ? ~~arguments[0].left\n          : w.scrollX || w.pageXOffset,\n        arguments[0].top !== undefined\n          ? ~~arguments[0].top\n          : w.scrollY || w.pageYOffset\n      );\n    };\n\n    // w.scrollBy\n    w.scrollBy = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0])) {\n        original.scrollBy.call(\n          w,\n          arguments[0].left !== undefined\n            ? arguments[0].left\n            : typeof arguments[0] !== 'object' ? arguments[0] : 0,\n          arguments[0].top !== undefined\n            ? arguments[0].top\n            : arguments[1] !== undefined ? arguments[1] : 0\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        ~~arguments[0].left + (w.scrollX || w.pageXOffset),\n        ~~arguments[0].top + (w.scrollY || w.pageYOffset)\n      );\n    };\n\n    // Element.prototype.scroll and Element.prototype.scrollTo\n    Element.prototype.scroll = Element.prototype.scrollTo = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        // if one number is passed, throw error to match Firefox implementation\n        if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n          throw new SyntaxError('Value could not be converted');\n        }\n\n        original.elementScroll.call(\n          this,\n          // use left prop, first number argument or fallback to scrollLeft\n          arguments[0].left !== undefined\n            ? ~~arguments[0].left\n            : typeof arguments[0] !== 'object' ? ~~arguments[0] : this.scrollLeft,\n          // use top prop, second argument or fallback to scrollTop\n          arguments[0].top !== undefined\n            ? ~~arguments[0].top\n            : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop\n        );\n\n        return;\n      }\n\n      var left = arguments[0].left;\n      var top = arguments[0].top;\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        this,\n        this,\n        typeof left === 'undefined' ? this.scrollLeft : ~~left,\n        typeof top === 'undefined' ? this.scrollTop : ~~top\n      );\n    };\n\n    // Element.prototype.scrollBy\n    Element.prototype.scrollBy = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.elementScroll.call(\n          this,\n          arguments[0].left !== undefined\n            ? ~~arguments[0].left + this.scrollLeft\n            : ~~arguments[0] + this.scrollLeft,\n          arguments[0].top !== undefined\n            ? ~~arguments[0].top + this.scrollTop\n            : ~~arguments[1] + this.scrollTop\n        );\n\n        return;\n      }\n\n      this.scroll({\n        left: ~~arguments[0].left + this.scrollLeft,\n        top: ~~arguments[0].top + this.scrollTop,\n        behavior: arguments[0].behavior\n      });\n    };\n\n    // Element.prototype.scrollIntoView\n    Element.prototype.scrollIntoView = function() {\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.scrollIntoView.call(\n          this,\n          arguments[0] === undefined ? true : arguments[0]\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      var scrollableParent = findScrollableParent(this);\n      var parentRects = scrollableParent.getBoundingClientRect();\n      var clientRects = this.getBoundingClientRect();\n\n      if (scrollableParent !== d.body) {\n        // reveal element inside parent\n        smoothScroll.call(\n          this,\n          scrollableParent,\n          scrollableParent.scrollLeft + clientRects.left - parentRects.left,\n          scrollableParent.scrollTop + clientRects.top - parentRects.top\n        );\n\n        // reveal parent in viewport unless is fixed\n        if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n          w.scrollBy({\n            left: parentRects.left,\n            top: parentRects.top,\n            behavior: 'smooth'\n          });\n        }\n      } else {\n        // reveal element in viewport\n        w.scrollBy({\n          left: clientRects.left,\n          top: clientRects.top,\n          behavior: 'smooth'\n        });\n      }\n    };\n  }\n\n  if (typeof exports === 'object' && typeof module !== 'undefined') {\n    // commonjs\n    module.exports = { polyfill: polyfill };\n  } else {\n    // global\n    polyfill();\n  }\n\n}());\n","const rootObj = { __sap_ES_MODULE__: true };\n(function() {\n  // @ts-check\r\n\r\n/** @license MIT smoothscroll-anchor-polyfill 1.3.0 (c) 2019 Jonas Kuske */\r\n\r\nvar _DEBUG_ = true; // removed during minification\r\n\r\n(function(/** @type {any} */ root, factory) {\r\n  var isESModule = root && root.__sap_ES_MODULE__\r\n  // @ts-ignore\r\n  if (!isESModule && typeof define === 'function' && define.amd) define([], factory);\r\n  else if (!isESModule && typeof module === 'object' && module.exports) module.exports = factory();\r\n  else root.SmoothscrollAnchorPolyfill = factory();\r\n})(this, function() {\r\n  function SmoothscrollAnchorPolyfill() {\r\n    var instance = this, isBrowser = typeof window !== 'undefined';\r\n\r\n    if (isBrowser) {\r\n      /**\r\n       * Add flag to Window interface, workaround for type check\r\n       * @typedef {{__forceSmoothscrollAnchorPolyfill__: [boolean]}} GlobalFlag @deprecated\r\n       * @typedef {Window & GlobalFlag} WindowWithFlag\r\n       * @type {WindowWithFlag} */\r\n      var w = (window), d = document, docEl = d.documentElement, dummy = d.createElement('a');\r\n    }\r\n\r\n    /**\r\n     * Starts the polyfill by attaching the neccessary EventListeners\r\n     *\r\n     * Aborts, if ('scrollBehavior' in documentElement.style) and the force flag\r\n     * isn't set on the options parameter Object or globally on window\r\n     * @param {PolyfillOptions} [opts] Options for invoking the polyfill\r\n     * @returns {SmoothscrollAnchorPolyfill} Polyfill Instance, allows for chaining\r\n     *\r\n     * @typedef {Object} PolyfillOptions\r\n     * @prop {boolean} [force] Enable despite native support, overrides global flag\r\n     */\r\n    this.polyfill = function(opts) {\r\n      opts = opts || {};\r\n      if (isBrowser) {\r\n        /** @deprecated */\r\n        var globalFlag = w.__forceSmoothscrollAnchorPolyfill__;\r\n        var force = typeof opts.force === 'boolean' ? opts.force : globalFlag;\r\n\r\n        // Abort if smoothscroll has native support and force flag isn't set\r\n        if ('scrollBehavior' in dummy.style && !force) return instance;\r\n\r\n        instance.destroy(); // Remove previous listeners\r\n        d.addEventListener('click', handleClick, false);\r\n        d.addEventListener('scroll', trackScrollPositions);\r\n        w.addEventListener('hashchange', handleHashChange);\r\n      }\r\n      return instance;\r\n    };\r\n\r\n    /**\r\n     * Stops the polyfill by removing all EventListeners\r\n     * @returns {SmoothscrollAnchorPolyfill} Polyfill Instance, allows for chaining\r\n     * @param {DestroyOptions} [opts] Options for destroying the polyfill\r\n     *\r\n     * @typedef {Object} DestroyOptions\r\n     * @prop {HTMLAnchorElement} [_dummy] DON'T USE THIS. INTERNAL USE ONLY.\r\n     */\r\n    this.destroy = function(opts) {\r\n      opts = opts || {};\r\n      // For testing purposes only: support injection of external dummy element\r\n      // Allows controlling whether env is treated as env with native support\r\n      if (_DEBUG_ && opts._dummy) dummy = opts._dummy;\r\n\r\n      if (isBrowser) {\r\n        d.removeEventListener('click', handleClick, false);\r\n        d.removeEventListener('scroll', trackScrollPositions);\r\n        w.removeEventListener('hashchange', handleHashChange);\r\n      }\r\n      return instance;\r\n    };\r\n\r\n    if (!isBrowser) return;\r\n\r\n    // Check if browser supports focus without automatic scrolling (preventScroll)\r\n    var supportsPreventScroll = false;\r\n    try {\r\n      // Define getter for preventScroll to find out if the browser accesses it\r\n      var preppedFocusOption = Object.defineProperty({}, 'preventScroll', {\r\n        get: function() {\r\n          supportsPreventScroll = true;\r\n        }\r\n      });\r\n      // Trigger focus – if browser uses preventScroll the var will be set to true\r\n      dummy.focus(preppedFocusOption);\r\n    } catch (e) { }\r\n\r\n    // Regex to extract the value following the scroll-behavior property name\r\n    var extractValue = /scroll-behavior:[\\s]*([^;\"`'\\s]+)/;\r\n    var docElStyle = getComputedStyle(docEl)\r\n\r\n    /**\r\n     * Returns true if scroll-behavior: smooth is set and not overwritten\r\n     * by a higher-specifity declaration, else returns false\r\n     */\r\n    function shouldSmoothscroll() {\r\n      // Values to check for set scroll-behavior in order of priority/specificity\r\n      var valuesToCheck = [\r\n        // Priority 1: behavior assigned to style property\r\n        // Allows toggling smoothscroll from JS (docEl.style.scrollBehavior = ...)\r\n        docEl.style.scrollBehavior,\r\n        // Priority 2: behavior specified inline in style attribute\r\n        (extractValue.exec(docEl.getAttribute('style')) || [])[1],\r\n        // Priority 3: custom property\r\n        // Behaves like regular CSS, e.g. allows using media queries\r\n        docElStyle.getPropertyValue('--scroll-behavior'),\r\n        // Priority 4: behavior specified in fontFamily\r\n        // Same use case as priority 3, but supports legacy browsers without CSS vars\r\n        (extractValue.exec(docElStyle.fontFamily) || [])[1]\r\n      ];\r\n\r\n      // Loop over values in specified order, return once a valid value is found\r\n      for (var i = 0; i < valuesToCheck.length; i++) {\r\n        var specifiedBehavior = getScrollBehavior(valuesToCheck[i]);\r\n        if (specifiedBehavior !== null) return specifiedBehavior;\r\n      }\r\n      // No value found? Return false, no set value = no smoothscroll :(\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * If a valid CSS property value for scroll-behavior is passed, returns\r\n     * whether it specifies smooth scroll behavior or not, else returns null\r\n     * @param {?string} value The value to check\r\n     * @returns {?boolean} The specified scroll behavior or null\r\n     */\r\n    function getScrollBehavior(value) {\r\n      var status = null;\r\n      value = value && value.trim();\r\n      if (/^smooth$/.test(value)) status = true;\r\n      if (/^(initial|inherit|auto|unset)$/.test(value)) status = false;\r\n      return status;\r\n    }\r\n\r\n    /**\r\n     * Get the target element of an event\r\n     * @param {Event} evt\r\n     * @returns {HTMLElement}\r\n     */\r\n    function getEventTarget(evt) {\r\n      evt = evt || w.event;\r\n      return /** @type {HTMLElement} */ (evt.target || evt.srcElement);\r\n    }\r\n\r\n    /**\r\n     * Check if an element is an anchor pointing to a target on the current page\r\n     * @param {HTMLAnchorElement} el\r\n     * @returns {boolean}\r\n     */\r\n    function isAnchorToLocalElement(el) {\r\n      // Check if element is an anchor with a fragment in the url\r\n      if (!/^a$/i.test(el.tagName) || !/#/.test(el.href)) return false;\r\n\r\n      // Fix bug in IE9 where anchor.pathname misses leading slash\r\n      var anchorPath = el.pathname;\r\n      if (anchorPath[0] !== '/') anchorPath = '/' + anchorPath;\r\n\r\n      // Check if anchor targets an element on the current page\r\n      return (el.hostname === location.hostname && anchorPath === location.pathname);\r\n    }\r\n\r\n    /**\r\n     * Focuses an element, if it's not focused after the first try,\r\n     * allow focusing by adjusting tabIndex and retry\r\n     * @param {HTMLElement} el\r\n     */\r\n    function focusElement(el) {\r\n      el.focus({ preventScroll: true });\r\n      if (d.activeElement !== el) {\r\n        var prevTabIndex = el.getAttribute('tabindex');\r\n        el.setAttribute('tabindex', '-1');\r\n\r\n        if (getComputedStyle(el).outlineStyle === 'none') {\r\n          var prevOutline = el.style.outlineStyle;\r\n          el.style.outlineStyle = 'none';\r\n          el.addEventListener('blur', function undoOutlineChange() {\r\n            el.style.outlineStyle = prevOutline;\r\n            el.setAttribute('tabindex', prevTabIndex);\r\n            el.removeEventListener('blur', undoOutlineChange);\r\n          })\r\n        }\r\n\r\n        el.focus({ preventScroll: true });\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Returns the element whose id matches the hash or\r\n     * document.body if the hash is \"#top\" or \"\" (empty string)\r\n     * @param {string} hash\r\n     */\r\n    function getScrollTarget(hash) {\r\n      if (typeof hash !== 'string') return null;\r\n      hash = decodeHash(hash);\r\n\r\n      // Retrieve target if an id is specified in the hash, otherwise use body.\r\n      // If hash is \"#top\" and no target with id \"top\" was found, also use body\r\n      // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-href\r\n      var target = hash ? d.getElementById(hash.slice(1)) : d.body;\r\n      if (hash === '#top' && !target) target = d.body;\r\n      return target;\r\n    }\r\n\r\n    /**\r\n     * Takes a URL-encoded hash and returns the decoded version.\r\n     * @param {string} hash Hash to decode\r\n     */\r\n    function decodeHash(hash) {\r\n      try {\r\n        // \"#%F0%9F%91%8D%F0%9F%8F%BB\" -> \"#👍🏻\"\r\n        hash = decodeURIComponent(hash);\r\n      } catch (e) { /* */ }\r\n      return hash;\r\n    }\r\n\r\n    /**\r\n     * Walks up the DOM starting from \"element\" until an element satisfies \"validate()\"\r\n     * @param {HTMLElement} element The element from where to start validating\r\n     * @param {function} validate Validation function, receives current element as arg\r\n     * @returns {?HTMLElement} The found element or null\r\n     */\r\n    function findInParents(element, validate) {\r\n      if (validate(element)) return element;\r\n      if (element.parentElement) return findInParents(element.parentElement, validate);\r\n      return null;\r\n    }\r\n\r\n    // Stores the setTimeout id of pending focus changes, allows aborting them\r\n    var pendingFocusChange;\r\n\r\n    /**\r\n     * Scrolls to a given element or to the top if the given element\r\n     * is document.body, then focuses the element\r\n     * @param {HTMLElement} target\r\n     */\r\n    function triggerSmoothscroll(target) {\r\n      // Clear potential pending focus change triggered by a previous scroll\r\n      if (!supportsPreventScroll) clearTimeout(pendingFocusChange);\r\n\r\n      // Use JS scroll APIs to scroll to top (if target is body) or to the element\r\n      // This allows polyfills for these APIs to do their smooth scrolling magic\r\n      var scrollTop = target === d.body;\r\n      if (scrollTop) w.scroll({ top: 0, left: 0, behavior: 'smooth' });\r\n      else target.scrollIntoView({ behavior: 'smooth', block: 'start' });\r\n\r\n      // If the browser supports preventScroll: immediately focus the target\r\n      // Otherwise schedule the focus so the smoothscroll isn't interrupted\r\n      if (supportsPreventScroll) focusElement(target);\r\n      else pendingFocusChange = setTimeout(focusElement.bind(null, target), 450);\r\n    }\r\n\r\n    /**\r\n     * Check if the clicked target is an anchor pointing to a local element,\r\n     * if so prevent the default behavior and handle the scrolling using the\r\n     * native JavaScript scroll APIs so smoothscroll polyfills apply\r\n     * @param {MouseEvent} evt\r\n     */\r\n    function handleClick(evt) {\r\n      // Abort if shift/ctrl-click or not primary click (button !== 0)\r\n      if (evt.metaKey || evt.ctrlKey || evt.shiftKey || evt.button !== 0) return;\r\n      // scroll-behavior not set to smooth? Bail out, let browser handle it\r\n      if (!shouldSmoothscroll()) return;\r\n\r\n      // Check the DOM from the click target upwards if a local anchor was clicked\r\n      var anchor = /** @type {?HTMLAnchorElement} */ (\r\n        findInParents(getEventTarget(evt), isAnchorToLocalElement)\r\n      );\r\n      if (!anchor) return;\r\n\r\n      // Find the element targeted by the hash\r\n      var hash = anchor.hash;\r\n      var target = getScrollTarget(hash);\r\n\r\n      if (target) {\r\n        // Prevent default browser behavior to avoid a jump to the anchor target\r\n        evt.preventDefault();\r\n\r\n        // Trigger the smooth scroll\r\n        triggerSmoothscroll(target);\r\n\r\n        // Append the hash to the URL\r\n        if (history.pushState) history.pushState(null, d.title, (hash || '#'));\r\n      }\r\n    }\r\n\r\n    // To enable smooth scrolling on hashchange, we need to immediately restore\r\n    // the scroll pos after a hashchange changed it, so we track it constantly.\r\n    // Some browsers don't trigger a scroll event before the hashchange,\r\n    // so to undo, the position from last scroll is the one we need to go back to.\r\n    // In others (e.g. IE) the scroll listener is triggered again before the\r\n    // hashchange occurs and the last reported position is already the new one\r\n    // updated by the hashchange – we need the second last to undo there.\r\n    // Because of this we don't track just the last, but the last two positions.\r\n    var lastTwoScrollPos = [];\r\n\r\n    /**\r\n      * Tries to undo the automatic, instant scroll caused by a hashchange\r\n      * and instead scrolls smoothly to the new hash target\r\n      */\r\n    function handleHashChange() {\r\n      // scroll-behavior not set to smooth or body not parsed yet? Abort\r\n      if (!d.body || !shouldSmoothscroll()) return;\r\n\r\n      var target = getScrollTarget(location.hash);\r\n      if (!target) return;\r\n\r\n      // If the position last reported by the scroll listener is the same as the\r\n      // current one caused by a hashchange, go back to second last – else last\r\n      var currentPos = getScrollTop();\r\n      var top = lastTwoScrollPos[lastTwoScrollPos[1] === currentPos ? 0 : 1];\r\n\r\n      // @ts-ignore\r\n      // Undo the scroll caused by the hashchange...\r\n      // Using {behavior: 'instant'} even though it's not in the spec anymore as\r\n      // Blink & Gecko support it – once an engine with native support doesn't,\r\n      // we need to disable scroll-behavior during scroll reset, then restore\r\n      w.scroll({ top: top, behavior: 'instant' });\r\n      // ...and instead smoothscroll to the target\r\n      triggerSmoothscroll(target);\r\n    }\r\n\r\n    /**\r\n     * Returns the scroll offset towards the top\r\n     */\r\n    function getScrollTop() {\r\n      return docEl.scrollTop || d.body.scrollTop;\r\n    }\r\n\r\n    /**\r\n     * Update the last two scroll positions\r\n     */\r\n    function trackScrollPositions() {\r\n      if (!d.body) return; // Body not parsed yet? Abort\r\n      lastTwoScrollPos[0] = lastTwoScrollPos[1];\r\n      lastTwoScrollPos[1] = getScrollTop();\r\n    }\r\n  }\r\n\r\n  return new SmoothscrollAnchorPolyfill().polyfill();\r\n});\r\n\n}).call(rootObj);\n\nconst { SmoothscrollAnchorPolyfill } = rootObj;\nconst { destroy, polyfill } = SmoothscrollAnchorPolyfill;\n\nexport { destroy, polyfill };\nexport default SmoothscrollAnchorPolyfill;"]}