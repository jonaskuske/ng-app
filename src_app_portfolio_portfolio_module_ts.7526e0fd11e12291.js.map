{"version":3,"mappings":"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","names":["GetPost","constructor","id","GetPostSuccess","post","GetPostError","error","this","GetPostPage","page","GetPostPageSuccess","payload","GetPostPageError","static","stateClass","createSelector","state","entities","Object","values","keys","pageIds","map","isArray","item","Array","serializePageQuery","_a","params","URLSearchParams","value","patchObject","existing","clone","k","newValue","existingPropValue","newPropValue","isStateOperator","assign","createEntity","entity","lastUpdatedAt","Date","toISOString","isFetching","isRefreshing","isError","some","i","includes","concat","filter","prevEntity","apiUrl","environment","headersGetTotal","headers","wpTotal","get","Error","Number","headersGetTotalPages","wpTotalPages","getPageFromResponse","response","body","total","totalPages","PostsService","http","getCategory","getPostFromBasePost","categories","pipe","category","categoryName","name","getPost","switchMap","basePost","getPosts","perPage","HttpParams","fromObject","String","per_page","observe","forkJoin","i0","factory","PortfolioState","postsService","store","ngxsOnInit","ctx","dispatch","getState","setState","toString","patch","ids","uniq","addEntity","catchError","getPostSuccess","updateEntity","getPostError","console","getPostPage","query","existingQuery","pagination","pages","patchState","getPostPageSuccess","reduce","obj","p","addEntities","getPostPageError","__decorate","Action","f","State","defaults","options","getPageQuery","flat","PortfolioSelectors","SharedSelectors","Selector","y","postQueryFn","addHandler","removeHandler","resultSelector","fromEventPattern","mapOneOrManyArgs","Observable","subscriber","handler","e","next","length","retValue","isFunction","undefined","DEFAULT_CONFIG","connector","Subject","selector","config","operate","source","subject","from","subscribable","subscribe","fromSubscribable","add","inputs","project","popResultSelector","len","otherValues","hasValue","ready","innerFrom","createOperatorSubscriber","every","identity","noop","args","combineLatest","combineLatestInit","argsOrArgArray","YouTubePlayer","_ngZone","platformId","_youtubeContainer","_destroyed","_playerChanges","BehaviorSubject","_videoId","_height","_width","_startSeconds","_endSeconds","_suggestedQuality","_playerVars","_getLazyEmitter","stateChange","apiChange","playbackQualityChange","playbackRateChange","_isBrowser","isPlatformBrowser","videoId","height","width","startSeconds","endSeconds","suggestedQuality","playerVars","ngOnInit","iframeApiAvailableObs","of","window","YT","Player","iframeApiAvailableSubject","_existingApiReadyCallback","onYouTubeIframeAPIReady","run","take","startWith","playerObs","youtubeContainer","videoIdObs","widthObs","heightObs","playerVarsObs","ngZone","playerOptions","withLatestFrom","constructorOptions","sizeOptions","notifier","combineLatest$1","predicate","taking","index","skipWhile","_","doneSkipping","skipUntilRememberLatest","scan","syncPlayerState","distinctUntilChanged","createPlayerObservable","tap","player","onAbort","mergeMap","playerIsReady","emitter","aborted","resolved","onReady","event","target","removeEventListener","addEventListener","waitUntilReady","destroy","takeUntil","connect","subjectOrSubjectFactory","subjectFactory","ConnectableObservable","multicast","publish","_player","_pendingPlayerState","_initializePlayer","setSize","bindSizeToPlayer","suggestedQualityObs","setPlaybackQuality","bindSuggestedQualityToPlayer","startSecondsObs","endSecondsObs","destroyed","cueOptionsObs","filteredCueOptions","filterOnOther","getPlayerState","PlayerState","UNSTARTED","CUED","hasPlayerStarted","changedVideoId","changedPlayer","cueOptions","merge","cueVideoById","bindCueVideoCall","ngAfterViewInit","nativeElement","ngOnDestroy","complete","playVideo","_getPendingState","playbackState","PLAYING","pauseVideo","PAUSED","stopVideo","seekTo","seconds","allowSeekAhead","seek","mute","muted","unMute","isMuted","setVolume","volume","getVolume","setPlaybackRate","playbackRate","getPlaybackRate","getAvailablePlaybackRates","getVideoLoadedFraction","getCurrentTime","getPlaybackQuality","getAvailableQualityLevels","getDuration","getVideoUrl","getVideoEmbedCode","listener","observer","ɵfac","PLATFORM_ID","ɵcmp","selectors","Ht","o","s","encapsulation","container","videoOptions","newPlayer","runOutsideAngular","otherObs","filterFn","other","YouTubePlayerModule","ɵmod","ɵinj","ShowcaseComponent","document","type","url","opts","fuzzy","test","patterns","exec","tokens","split","getYoutubeId","video","loadYouTubeAPI","tag","createElement","src","appendChild","DOCUMENT","BriefingComponent","LoadingSpinnerComponent","ctx_r14","route","rawId","snapshot","paramMap","postEntity$","postEntityByIdFn$","postEntityById","post$","isFetching$","toTop","scrollIntoView","block","behavior","ctx_r9","PostDetailComponent","Select","C","linebreakRegex","posts$","postEntitiesByQueryFn$","postsForQuery","postEntities","query$","postQueryFn$","getPostQuery","q","loadPage","requestNextPage","getTeaser","text","replace","slice","PostMasterComponent","T","PortfolioRoutes","RouterModule","path","component","LoadingSpinnerModule","CommonModule","PostDetailModule","PostMasterModule","imports","PortfolioModule","NgxsModule"],"sources":["./src/app/portfolio/store/portfolio.actions.ts","./src/app/shared/store/selectors.ts","./src/app/shared/util/index.ts","./node_modules/@ngxs/store/fesm2015/ngxs-store-operators.js","./src/app/shared/util/store.ts","./src/app/portfolio/posts.service.ts","./src/app/portfolio/store/portfolio.state.ts","./src/app/portfolio/store/portfolio.selectors.ts","./node_modules/rxjs/dist/esm/internal/observable/fromEventPattern.js","./node_modules/rxjs/dist/esm/internal/operators/connect.js","./node_modules/rxjs/dist/esm/internal/observable/fromSubscribable.js","./node_modules/rxjs/dist/esm/internal/operators/withLatestFrom.js","./node_modules/rxjs/dist/esm/internal/util/argsOrArgArray.js","./node_modules/rxjs/dist/esm/internal/operators/combineLatest.js","./node_modules/@angular/youtube-player/fesm2015/youtube-player.mjs","./node_modules/rxjs/dist/esm/internal/operators/skipWhile.js","./node_modules/rxjs/dist/esm/internal/operators/publish.js","./node_modules/rxjs/dist/esm/internal/operators/multicast.js","./src/app/portfolio/components/showcase/showcase.component.html","./src/app/portfolio/components/showcase/showcase.component.ts","./src/app/portfolio/components/briefing/briefing.component.html","./src/app/portfolio/components/briefing/briefing.component.ts","./src/app/shared/components/loading-spinner/loading-spinner.component.ts","./src/app/shared/components/loading-spinner/loading-spinner.component.html","./src/app/portfolio/views/post-detail/post-detail.component.html","./src/app/portfolio/views/post-detail/post-detail.component.ts","./src/app/portfolio/views/post-master/post-master.component.html","./src/app/portfolio/views/post-master/post-master.component.ts","./src/app/portfolio/portfolio.module.routing.ts","./src/app/shared/components/loading-spinner/loading-spinner.module.ts","./src/app/portfolio/views/post-detail/post-detail.module.ts","./src/app/portfolio/views/post-master/post-master.module.ts","./src/app/portfolio/portfolio.module.ts"],"sourcesContent":["import { Page } from '../../shared/models'\nimport { Post } from '../models/post.model'\nimport { PostRequestOptions } from '../posts.service'\n\nexport class GetPost {\n  static readonly type = '[Portfolio] Get Post'\n  constructor(public id: number) {}\n}\nexport class GetPostSuccess {\n  static readonly type = '[Portfolio API] Get Post Success'\n  constructor(public post: Post) {}\n}\nexport class GetPostError {\n  static readonly type = '[Portfolio API] Get Post Error'\n  constructor(public id: number, public error: Error) {}\n}\n\nexport class GetPostPage {\n  static readonly type = '[Portfolio] Get Post Page'\n  constructor(public page: PostRequestOptions) {}\n}\nexport class GetPostPageSuccess {\n  static readonly type = '[Portfolio API] Get Post Page Success'\n  constructor(public page: PostRequestOptions, public payload: Page<Post>) {}\n}\nexport class GetPostPageError {\n  static readonly type = '[Portfolio API] Get Post Page Error'\n  constructor(public page: PostRequestOptions, public error: Error) {}\n}\n","import { createSelector } from '@ngxs/store'\nimport { Entity } from '../models'\n\nexport class SharedSelectors {\n  static getEntities<T>(stateClass) {\n    return createSelector([stateClass], (state) => state.entities as { [id: string]: Entity<T> })\n  }\n\n  static getEntityList<T>(stateClass) {\n    return createSelector([stateClass], (state) => Object.values(state.entities) as Entity<T>[])\n  }\n\n  static getEntityIds(stateClass) {\n    return createSelector([stateClass], (state) => Object.keys(state.entities))\n  }\n\n  static getEntityListByPageFn(stateClass) {\n    return (pageIds: number[]) => {\n      return createSelector([stateClass], (state) => pageIds.map((id) => state.entities[id]))\n    }\n  }\n}\n","export const isArray = (item: any): item is any[] => Array.isArray(item)\n\nexport const serializePageQuery = ({ page, ...params }: any) => `?${new URLSearchParams(params)}`\n\nexport const getYoutubeId = (url: string, opts = { fuzzy: true }) => {\n  if (!/youtu\\.?be/.test(url)) return null\n\n  // Look first for known patterns\n  let i: number\n  const patterns = [\n    /youtu\\.be\\/([^#&?]{11})/, // youtu.be/<id>\n    /\\?v=([^#&?]{11})/, // ?v=<id>\n    /&v=([^#&?]{11})/, // &v=<id>\n    /embed\\/([^#&?]{11})/, // embed/<id>\n    /\\/v\\/([^#&?]{11})/, // /v/<id>\n  ]\n\n  // If any pattern matches, return the ID\n  for (i = 0; i < patterns.length; ++i) {\n    if (patterns[i].test(url)) {\n      return patterns[i].exec(url)[1]\n    }\n  }\n\n  if (opts.fuzzy) {\n    // If that fails, break it apart by certain characters and look\n    // for the 11 character key\n    const tokens = url.split(/[/&?=#.\\s]/g)\n    for (i = 0; i < tokens.length; ++i) {\n      if (/^[^#&?]{11}$/.test(tokens[i])) {\n        return tokens[i]\n      }\n    }\n  }\n}\n","/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @template T\r\n * @param {?} items - Specific items to append to the end of an array\r\n * @return {?}\r\n */\r\nfunction append(items) {\r\n    return (/**\r\n     * @param {?} existing\r\n     * @return {?}\r\n     */\r\n    function appendOperator(existing) {\r\n        // If `items` is `undefined` or `null` or `[]` but `existing` is provided\r\n        // just return `existing`\r\n        /** @type {?} */\r\n        const itemsNotProvidedButExistingIs = (!items || !items.length) && existing;\r\n        if (itemsNotProvidedButExistingIs) {\r\n            return (/** @type {?} */ (existing));\r\n        }\r\n        if (Array.isArray(existing)) {\r\n            return existing.concat((/** @type {?} */ (items)));\r\n        }\r\n        // For example if some property is added dynamically\r\n        // and didn't exist before thus it's not `ArrayLike`\r\n        return (/** @type {?} */ (items));\r\n    });\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @template T\r\n * @param {...?} operators\r\n * @return {?}\r\n */\r\nfunction compose(...operators) {\r\n    return (/**\r\n     * @param {?} existing\r\n     * @return {?}\r\n     */\r\n    function composeOperator(existing) {\r\n        return operators.reduce((/**\r\n         * @param {?} accumulator\r\n         * @param {?} operator\r\n         * @return {?}\r\n         */\r\n        (accumulator, operator) => operator(accumulator)), existing);\r\n    });\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @template T\r\n * @param {?} value\r\n * @return {?}\r\n */\r\nfunction isStateOperator(value) {\r\n    return typeof value === 'function';\r\n}\r\n/**\r\n * @param {?} value\r\n * @return {?}\r\n */\r\nfunction isUndefined(value) {\r\n    return typeof value === 'undefined';\r\n}\r\n/**\r\n * @template T\r\n * @param {?} value\r\n * @return {?}\r\n */\r\nfunction isPredicate(value) {\r\n    return typeof value === 'function';\r\n}\r\n/**\r\n * @param {?} value\r\n * @return {?}\r\n */\r\nfunction isNumber(value) {\r\n    return typeof value === 'number';\r\n}\r\n/**\r\n * @param {?} index\r\n * @return {?}\r\n */\r\nfunction invalidIndex(index) {\r\n    return Number.isNaN(index) || index === -1;\r\n}\r\n/**\r\n * @template T\r\n * @param {?} value\r\n * @return {?}\r\n */\r\nfunction isNil(value) {\r\n    return value === null || isUndefined(value);\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @template T\r\n * @param {?} operatorOrValue\r\n * @param {?=} existing\r\n * @return {?}\r\n */\r\nfunction retrieveValue(operatorOrValue, existing) {\r\n    // If state operator is a function\r\n    // then call it with an original value\r\n    if (isStateOperator(operatorOrValue)) {\r\n        /** @type {?} */\r\n        const value = operatorOrValue((/** @type {?} */ ((/** @type {?} */ (existing)))));\r\n        return (/** @type {?} */ (value));\r\n    }\r\n    // If operator or value was not provided\r\n    // e.g. `elseOperatorOrValue` is `undefined`\r\n    // then we just return an original value\r\n    if (isUndefined(operatorOrValue)) {\r\n        return (/** @type {?} */ ((/** @type {?} */ (((/** @type {?} */ (existing)))))));\r\n    }\r\n    return (/** @type {?} */ (operatorOrValue));\r\n}\r\n/**\r\n * @template T\r\n * @param {?} condition - Condition can be a plain boolean value or a function,\r\n * that returns boolean, also this function can take a value as an argument\r\n * to which this state operator applies\r\n * @param {?} trueOperatorOrValue - Any value or a state operator\r\n * @param {?=} elseOperatorOrValue - Any value or a state operator\r\n * @return {?}\r\n */\r\nfunction iif(condition, trueOperatorOrValue, elseOperatorOrValue) {\r\n    return (/**\r\n     * @param {?} existing\r\n     * @return {?}\r\n     */\r\n    function iifOperator(existing) {\r\n        // Convert the value to a boolean\r\n        /** @type {?} */\r\n        let result = !!condition;\r\n        // but if it is a function then run it to get the result\r\n        if (isPredicate(condition)) {\r\n            result = condition(existing);\r\n        }\r\n        if (result) {\r\n            return retrieveValue(trueOperatorOrValue, (/** @type {?} */ (existing)));\r\n        }\r\n        return retrieveValue((/** @type {?} */ (elseOperatorOrValue)), (/** @type {?} */ (existing)));\r\n    });\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @template T\r\n * @param {?} value - Value to insert\r\n * @param {?=} beforePosition\r\n * @return {?}\r\n */\r\nfunction insertItem(value, beforePosition) {\r\n    return (/**\r\n     * @param {?} existing\r\n     * @return {?}\r\n     */\r\n    function insertItemOperator(existing) {\r\n        // Have to check explicitly for `null` and `undefined`\r\n        // because `value` can be `0`, thus `!value` will return `true`\r\n        if (isNil(value) && existing) {\r\n            return (/** @type {?} */ (existing));\r\n        }\r\n        // Property may be dynamic and might not existed before\r\n        if (!Array.isArray(existing)) {\r\n            return [(/** @type {?} */ (value))];\r\n        }\r\n        /** @type {?} */\r\n        const clone = existing.slice();\r\n        /** @type {?} */\r\n        let index = 0;\r\n        // No need to call `isNumber`\r\n        // as we are checking `> 0` not `>= 0`\r\n        // everything except number will return false here\r\n        if ((/** @type {?} */ (beforePosition)) > 0) {\r\n            index = (/** @type {?} */ (beforePosition));\r\n        }\r\n        clone.splice(index, 0, (/** @type {?} */ (value)));\r\n        return clone;\r\n    });\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @template T\r\n * @param {?} patchObject\r\n * @return {?}\r\n */\r\nfunction patch(patchObject) {\r\n    return (/**\r\n     * @template U\r\n     * @param {?} existing\r\n     * @return {?}\r\n     */\r\n    function patchStateOperator(existing) {\r\n        /** @type {?} */\r\n        let clone = null;\r\n        for (const k in patchObject) {\r\n            /** @type {?} */\r\n            const newValue = patchObject[k];\r\n            /** @type {?} */\r\n            const existingPropValue = existing[k];\r\n            /** @type {?} */\r\n            const newPropValue = isStateOperator(newValue)\r\n                ? newValue((/** @type {?} */ (existingPropValue)))\r\n                : newValue;\r\n            if (newPropValue !== existingPropValue) {\r\n                if (!clone) {\r\n                    clone = Object.assign({}, ((/** @type {?} */ (existing))));\r\n                }\r\n                clone[k] = newPropValue;\r\n            }\r\n        }\r\n        return clone || existing;\r\n    });\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @template T\r\n * @param {?} selector - Index of item in the array or a predicate function\r\n * that can be provided in `Array.prototype.findIndex`\r\n * @param {?} operatorOrValue - New value under the `selector` index or a\r\n * function that can be applied to an existing value\r\n * @return {?}\r\n */\r\nfunction updateItem(selector, operatorOrValue) {\r\n    return (/**\r\n     * @param {?} existing\r\n     * @return {?}\r\n     */\r\n    function updateItemOperator(existing) {\r\n        /** @type {?} */\r\n        let index = -1;\r\n        if (isPredicate(selector)) {\r\n            index = existing.findIndex(selector);\r\n        }\r\n        else if (isNumber(selector)) {\r\n            index = selector;\r\n        }\r\n        if (invalidIndex(index)) {\r\n            return (/** @type {?} */ (existing));\r\n        }\r\n        /** @type {?} */\r\n        let value = (/** @type {?} */ (null));\r\n        // Need to check if the new item value will change the existing item value\r\n        // then, only if it will change it then clone the array and set the item\r\n        if (isStateOperator(operatorOrValue)) {\r\n            value = operatorOrValue((/** @type {?} */ (existing[index])));\r\n        }\r\n        else {\r\n            value = operatorOrValue;\r\n        }\r\n        // If the value hasn't been mutated\r\n        // then we just return `existing` array\r\n        if (value === existing[index]) {\r\n            return (/** @type {?} */ (existing));\r\n        }\r\n        /** @type {?} */\r\n        const clone = existing.slice();\r\n        clone[index] = (/** @type {?} */ (value));\r\n        return clone;\r\n    });\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @template T\r\n * @param {?} selector - index or predicate to remove an item from an array by\r\n * @return {?}\r\n */\r\nfunction removeItem(selector) {\r\n    return (/**\r\n     * @param {?} existing\r\n     * @return {?}\r\n     */\r\n    function removeItemOperator(existing) {\r\n        /** @type {?} */\r\n        let index = -1;\r\n        if (isPredicate(selector)) {\r\n            index = existing.findIndex(selector);\r\n        }\r\n        else if (isNumber(selector)) {\r\n            index = selector;\r\n        }\r\n        if (invalidIndex(index)) {\r\n            return (/** @type {?} */ (existing));\r\n        }\r\n        /** @type {?} */\r\n        const clone = existing.slice();\r\n        clone.splice(index, 1);\r\n        return clone;\r\n    });\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\nexport { append, compose, iif, insertItem, isStateOperator, patch, removeItem, updateItem };\n\n","import { StateOperator } from '@ngxs/store'\nimport { patch } from '@ngxs/store/operators'\nimport { Entity, EntityPartial, PaginatedEntities } from '../models'\n\nimport { isArray } from '.'\n\nexport const createEntity = <T>(id: Entity<T>['id'], entity: T = null): Entity<T> => ({\n  id,\n  entity,\n  lastUpdatedAt: new Date().toISOString(),\n  isFetching: false,\n  isRefreshing: false,\n  isError: false,\n})\n\nexport function uniq(item: any | any[]): StateOperator<any[]> {\n  return (state: any[]) => {\n    const noUniq = isArray(item) ? item.some((i) => !state.includes(i)) : state.includes(item)\n    if (noUniq) {\n      return state\n    }\n\n    return state.concat(isArray(item) ? item.filter((i) => !state.includes(i)) : item)\n  }\n}\n\nexport function addEntity<T>(entity: Entity<T>): StateOperator<PaginatedEntities<T>> {\n  const id = entity.id.toString()\n  return patch<PaginatedEntities<T>>({ ids: uniq(id), entities: patch({ [id]: entity }) })\n}\n\nexport function addEntities<T>(payload: Entity<T>[]): StateOperator<PaginatedEntities<T>> {\n  const entities = payload.reduce((obj, entity) => ((obj[entity.id] = entity), obj), {})\n  return patch<PaginatedEntities<T>>({\n    ids: uniq(payload.map((p) => p.id.toString())),\n    entities: patch(entities),\n  })\n}\n\nexport function updateEntity<T>(payload: EntityPartial<T>): StateOperator<PaginatedEntities<T>> {\n  return (state: PaginatedEntities<T>) => {\n    const prevEntity = state.entities[payload.id]\n    return {\n      ...state,\n      entities: { ...state.entities, [payload.id]: { ...prevEntity, ...payload } },\n    }\n  }\n}\n","import { HttpClient, HttpHeaders, HttpParams, HttpResponse } from '@angular/common/http'\nimport { Injectable } from '@angular/core'\nimport { forkJoin } from 'rxjs'\n\nimport { map, switchMap } from 'rxjs/operators'\nimport { environment } from 'src/environments/environment'\n\nimport { Page } from '../shared/models'\n\nimport { BasePost, Category, Post } from './models/post.model'\n\nexport interface PostRequestOptions {\n  page: number\n  perPage?: number\n}\n\nconst { apiUrl } = environment\n\nconst headersGetTotal = (headers: HttpHeaders) => {\n  const wpTotal = headers.get('x-wp-total')\n  if (wpTotal == null) throw Error('Header \"x-wp-total\" missing in response')\n\n  return Number(wpTotal)\n}\nconst headersGetTotalPages = (headers: HttpHeaders) => {\n  const wpTotalPages = headers.get('x-wp-totalpages')\n  if (wpTotalPages == null) throw Error('Header \"x-wp-totalpages\" missing in response')\n\n  return Number(wpTotalPages)\n}\n\nconst getPageFromResponse = <T>(response: HttpResponse<T[]>): Page<T> => {\n  const { body, headers } = response\n  return { body, total: headersGetTotal(headers), totalPages: headersGetTotalPages(headers) }\n}\n\n@Injectable({ providedIn: 'root' })\nexport class PostsService {\n  constructor(private http: HttpClient) {}\n\n  getCategory(id: number) {\n    return this.http.get<Category>(`${apiUrl}categories/${id}`)\n  }\n\n  getPostFromBasePost(post: BasePost) {\n    return this.http\n      .get<Category>(`${apiUrl}categories/${post.categories[0]}`)\n      .pipe(map((category) => ({ ...post, categoryName: category.name } as Post)))\n  }\n\n  getPost(id: number) {\n    return this.http\n      .get<BasePost>(`${apiUrl}posts/${id}`)\n      .pipe(switchMap((basePost) => this.getPostFromBasePost(basePost)))\n  }\n\n  getPosts({ page, perPage = 10 }: PostRequestOptions) {\n    const params = new HttpParams({\n      fromObject: { page: String(page), per_page: String(perPage) },\n    })\n\n    return this.http.get<BasePost[]>(`${apiUrl}posts`, { params, observe: 'response' }).pipe(\n      switchMap((response) => {\n        return forkJoin(response.body.map((basePost) => this.getPostFromBasePost(basePost))).pipe(\n          map((body) => ({ ...response, body })),\n        )\n      }),\n      map(getPageFromResponse),\n    )\n  }\n}\n","import { Injectable } from '@angular/core'\n\nimport { catchError, map } from 'rxjs/operators'\n\nimport { Action, NgxsOnInit, State, StateContext, Store } from '@ngxs/store'\nimport { patch } from '@ngxs/store/operators'\nimport { PaginatedEntities } from '../../shared/models'\nimport { serializePageQuery } from '../../shared/util'\nimport { addEntities, addEntity, createEntity, updateEntity } from '../../shared/util/store'\nimport { Post } from '../models/post.model'\nimport { PostsService } from '../posts.service'\n\nimport {\n  GetPost,\n  GetPostError,\n  GetPostPage,\n  GetPostPageError,\n  GetPostPageSuccess,\n  GetPostSuccess,\n} from './portfolio.actions'\n\nexport type PortfolioStateModel = PaginatedEntities<Post>\nexport type PortfolioStateContext = StateContext<PortfolioStateModel>\n\nconst initialState: PortfolioStateModel = { entities: {}, ids: [], pagination: {} }\n\n@State<PortfolioStateModel>({ name: 'portfolio', defaults: initialState })\n@Injectable()\nexport class PortfolioState implements NgxsOnInit {\n  constructor(private postsService: PostsService, private store: Store) {}\n\n  ngxsOnInit(ctx: PortfolioStateContext) {\n    ctx.dispatch(new GetPostPage({ page: 1, perPage: 8 }))\n  }\n\n  @Action(GetPost)\n  getPost(ctx: PortfolioStateContext, { id }: GetPost) {\n    const existing = ctx.getState().entities[id]\n    if (existing && !existing.isError) {\n      return ctx.dispatch(new GetPostSuccess(existing.entity))\n    }\n\n    ctx.setState(addEntity<Post>({ ...createEntity<Post>(id), isFetching: true }))\n\n    return this.postsService.getPost(id).pipe(\n      map((response) => ctx.dispatch(new GetPostSuccess(response))),\n      catchError((error) => ctx.dispatch(new GetPostError(id, error))),\n    )\n  }\n\n  @Action(GetPostSuccess)\n  getPostSuccess(ctx: PortfolioStateContext, { post }: GetPostSuccess) {\n    ctx.setState(updateEntity<Post>(createEntity<Post>(post.id, post)))\n  }\n\n  @Action(GetPostError)\n  getPostError(ctx: PortfolioStateContext, { id, error }: GetPostError) {\n    ctx.setState(updateEntity({ id, isError: true, isFetching: false, isRefreshing: false }))\n    console.error(error)\n  }\n\n  @Action(GetPostPage)\n  getPostPage(ctx: PortfolioStateContext, { page }: GetPostPage) {\n    const state = ctx.getState()\n    const query = serializePageQuery(page)\n\n    const existingQuery = ctx.getState().pagination[query]\n    if (existingQuery && existingQuery.pages[page.page]) return\n\n    if (!existingQuery) {\n      ctx.patchState({\n        pagination: { ...state.pagination, [query]: { total: 0, totalPages: 0, pages: {} } },\n      })\n    }\n\n    ctx.setState(\n      patch({\n        pagination: patch({\n          [query]: patch({\n            pages: patch({ [page.page]: { ...createEntity(page.page), isFetching: true } }),\n          }),\n        }),\n      }),\n    )\n\n    return this.postsService.getPosts(page).pipe(\n      map((response) => ctx.dispatch(new GetPostPageSuccess(page, response))),\n      catchError((error) => ctx.dispatch(new GetPostPageError(page, error))),\n    )\n  }\n\n  @Action(GetPostPageSuccess)\n  getPostPageSuccess(ctx: PortfolioStateContext, { page, payload }: GetPostPageSuccess) {\n    const query = serializePageQuery(page)\n\n    const entities = payload.body.map((item) => createEntity(item.id, item))\n    const pageIds = payload.body.map((item) => item.id.toString())\n    ctx.setState(addEntities(entities))\n\n    ctx.setState(\n      patch({\n        pagination: patch({\n          [query]: patch({\n            total: payload.total,\n            totalPages: payload.totalPages,\n            pages: patch({ [page.page]: { ...createEntity(page.page, pageIds) } }),\n          }),\n        }),\n      }),\n    )\n  }\n\n  @Action(GetPostPageError)\n  getPostPageError(ctx: PortfolioStateContext, { page, error }: GetPostPageError) {\n    const query = serializePageQuery(page)\n    ctx.setState(\n      patch({\n        pagination: patch({\n          [query]: patch({\n            pages: patch({\n              [page.page]: patch({ isError: true, isRefreshing: false, isFetching: false }),\n            }),\n          }),\n        }),\n      }),\n    )\n    console.error(error)\n  }\n}\n","import { SharedSelectors } from 'src/app/shared/store/selectors'\nimport { serializePageQuery } from 'src/app/shared/util'\n\nimport { Selector } from '@ngxs/store'\nimport { Post } from '../models/post.model'\nimport { PostRequestOptions } from '../posts.service'\n\nimport { PortfolioState, PortfolioStateModel } from './portfolio.state'\n\nexport class PortfolioSelectors {\n  static entities = SharedSelectors.getEntities<Post>(PortfolioState)\n  static ids = SharedSelectors.getEntityIds(PortfolioState)\n  static posts = SharedSelectors.getEntityList<Post>(PortfolioState)\n\n  @Selector([PortfolioState])\n  static pagination(state: PortfolioStateModel) {\n    return state.pagination\n  }\n  @Selector([PortfolioSelectors.entities])\n  static postEntityByIdFn(entities: ReturnType<typeof PortfolioSelectors.entities>) {\n    return (id: number) => entities[id]\n  }\n  @Selector([PortfolioSelectors.pagination])\n  static postQueryFn(pagination: ReturnType<typeof PortfolioSelectors.pagination>) {\n    return (options: PostRequestOptions) => pagination[serializePageQuery(options)]\n  }\n  @Selector([PortfolioSelectors.postQueryFn])\n  static postQueryPageFn(getPageQuery: ReturnType<typeof PortfolioSelectors.postQueryFn>) {\n    return (options: PostRequestOptions) => getPageQuery(options).pages[options.page]\n  }\n  @Selector([PortfolioSelectors.entities, PortfolioSelectors.postQueryFn])\n  static postEntitiesByQueryFn(\n    entities: ReturnType<typeof PortfolioSelectors.entities>,\n    getPageQuery: ReturnType<typeof PortfolioSelectors.postQueryFn>,\n  ) {\n    return (options: PostRequestOptions) => {\n      const pages = Object.values(getPageQuery(options).pages).filter((p) => !p.isFetching)\n      const ids = pages.map((p) => p.entity).flat()\n      return ids.map((id) => entities[id])\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { isFunction } from '../util/isFunction';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nexport function fromEventPattern(addHandler, removeHandler, resultSelector) {\n    if (resultSelector) {\n        return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs(resultSelector));\n    }\n    return new Observable((subscriber) => {\n        const handler = (...e) => subscriber.next(e.length === 1 ? e[0] : e);\n        const retValue = addHandler(handler);\n        return isFunction(removeHandler) ? () => removeHandler(handler, retValue) : undefined;\n    });\n}\n","import { Subject } from '../Subject';\nimport { from } from '../observable/from';\nimport { operate } from '../util/lift';\nimport { fromSubscribable } from '../observable/fromSubscribable';\nconst DEFAULT_CONFIG = {\n    connector: () => new Subject(),\n};\nexport function connect(selector, config = DEFAULT_CONFIG) {\n    const { connector } = config;\n    return operate((source, subscriber) => {\n        const subject = connector();\n        from(selector(fromSubscribable(subject))).subscribe(subscriber);\n        subscriber.add(source.subscribe(subject));\n    });\n}\n","import { Observable } from '../Observable';\nexport function fromSubscribable(subscribable) {\n    return new Observable((subscriber) => subscribable.subscribe(subscriber));\n}\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { identity } from '../util/identity';\nimport { noop } from '../util/noop';\nimport { popResultSelector } from '../util/args';\nexport function withLatestFrom(...inputs) {\n    const project = popResultSelector(inputs);\n    return operate((source, subscriber) => {\n        const len = inputs.length;\n        const otherValues = new Array(len);\n        let hasValue = inputs.map(() => false);\n        let ready = false;\n        for (let i = 0; i < len; i++) {\n            innerFrom(inputs[i]).subscribe(createOperatorSubscriber(subscriber, (value) => {\n                otherValues[i] = value;\n                if (!ready && !hasValue[i]) {\n                    hasValue[i] = true;\n                    (ready = hasValue.every(identity)) && (hasValue = null);\n                }\n            }, noop));\n        }\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            if (ready) {\n                const values = [value, ...otherValues];\n                subscriber.next(project ? project(...values) : values);\n            }\n        }));\n    });\n}\n","const { isArray } = Array;\nexport function argsOrArgArray(args) {\n    return args.length === 1 && isArray(args[0]) ? args[0] : args;\n}\n","import { combineLatestInit } from '../observable/combineLatest';\nimport { operate } from '../util/lift';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { pipe } from '../util/pipe';\nimport { popResultSelector } from '../util/args';\nexport function combineLatest(...args) {\n    const resultSelector = popResultSelector(args);\n    return resultSelector\n        ? pipe(combineLatest(...args), mapOneOrManyArgs(resultSelector))\n        : operate((source, subscriber) => {\n            combineLatestInit([source, ...argsOrArgArray(args)])(subscriber);\n        });\n}\n","import * as i0 from '@angular/core';\nimport { PLATFORM_ID, Component, ChangeDetectionStrategy, ViewEncapsulation, Inject, Input, Output, ViewChild, NgModule } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, BehaviorSubject, of, combineLatest, pipe, Observable, fromEventPattern, merge } from 'rxjs';\nimport { take, startWith, combineLatest as combineLatest$1, skipWhile, map, scan, distinctUntilChanged, tap, mergeMap, takeUntil, publish, switchMap, withLatestFrom, filter } from 'rxjs/operators';\n\n/// <reference types=\"youtube\" />\nconst DEFAULT_PLAYER_WIDTH = 640;\nconst DEFAULT_PLAYER_HEIGHT = 390;\n/**\n * Angular component that renders a YouTube player via the YouTube player\n * iframe API.\n * @see https://developers.google.com/youtube/iframe_api_reference\n */\nclass YouTubePlayer {\n    constructor(_ngZone, platformId) {\n        this._ngZone = _ngZone;\n        this._youtubeContainer = new Subject();\n        this._destroyed = new Subject();\n        this._playerChanges = new BehaviorSubject(undefined);\n        this._videoId = new BehaviorSubject(undefined);\n        this._height = new BehaviorSubject(DEFAULT_PLAYER_HEIGHT);\n        this._width = new BehaviorSubject(DEFAULT_PLAYER_WIDTH);\n        this._startSeconds = new BehaviorSubject(undefined);\n        this._endSeconds = new BehaviorSubject(undefined);\n        this._suggestedQuality = new BehaviorSubject(undefined);\n        this._playerVars = new BehaviorSubject(undefined);\n        /** Outputs are direct proxies from the player itself. */\n        this.ready = this._getLazyEmitter('onReady');\n        this.stateChange = this._getLazyEmitter('onStateChange');\n        this.error = this._getLazyEmitter('onError');\n        this.apiChange = this._getLazyEmitter('onApiChange');\n        this.playbackQualityChange = this._getLazyEmitter('onPlaybackQualityChange');\n        this.playbackRateChange = this._getLazyEmitter('onPlaybackRateChange');\n        this._isBrowser = isPlatformBrowser(platformId);\n    }\n    /** YouTube Video ID to view */\n    get videoId() {\n        return this._videoId.value;\n    }\n    set videoId(videoId) {\n        this._videoId.next(videoId);\n    }\n    /** Height of video player */\n    get height() {\n        return this._height.value;\n    }\n    set height(height) {\n        this._height.next(height || DEFAULT_PLAYER_HEIGHT);\n    }\n    /** Width of video player */\n    get width() {\n        return this._width.value;\n    }\n    set width(width) {\n        this._width.next(width || DEFAULT_PLAYER_WIDTH);\n    }\n    /** The moment when the player is supposed to start playing */\n    set startSeconds(startSeconds) {\n        this._startSeconds.next(startSeconds);\n    }\n    /** The moment when the player is supposed to stop playing */\n    set endSeconds(endSeconds) {\n        this._endSeconds.next(endSeconds);\n    }\n    /** The suggested quality of the player */\n    set suggestedQuality(suggestedQuality) {\n        this._suggestedQuality.next(suggestedQuality);\n    }\n    /**\n     * Extra parameters used to configure the player. See:\n     * https://developers.google.com/youtube/player_parameters.html?playerVersion=HTML5#Parameters\n     */\n    get playerVars() {\n        return this._playerVars.value;\n    }\n    set playerVars(playerVars) {\n        this._playerVars.next(playerVars);\n    }\n    ngOnInit() {\n        // Don't do anything if we're not in a browser environment.\n        if (!this._isBrowser) {\n            return;\n        }\n        let iframeApiAvailableObs = of(true);\n        if (!window.YT || !window.YT.Player) {\n            if (this.showBeforeIframeApiLoads && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw new Error('Namespace YT not found, cannot construct embedded youtube player. ' +\n                    'Please install the YouTube Player API Reference for iframe Embeds: ' +\n                    'https://developers.google.com/youtube/iframe_api_reference');\n            }\n            const iframeApiAvailableSubject = new Subject();\n            this._existingApiReadyCallback = window.onYouTubeIframeAPIReady;\n            window.onYouTubeIframeAPIReady = () => {\n                if (this._existingApiReadyCallback) {\n                    this._existingApiReadyCallback();\n                }\n                this._ngZone.run(() => iframeApiAvailableSubject.next(true));\n            };\n            iframeApiAvailableObs = iframeApiAvailableSubject.pipe(take(1), startWith(false));\n        }\n        // An observable of the currently loaded player.\n        const playerObs = createPlayerObservable(this._youtubeContainer, this._videoId, iframeApiAvailableObs, this._width, this._height, this._playerVars, this._ngZone).pipe(tap(player => {\n            // Emit this before the `waitUntilReady` call so that we can bind to\n            // events that happen as the player is being initialized (e.g. `onReady`).\n            this._playerChanges.next(player);\n        }), waitUntilReady(player => {\n            // Destroy the player if loading was aborted so that we don't end up leaking memory.\n            if (!playerIsReady(player)) {\n                player.destroy();\n            }\n        }), takeUntil(this._destroyed), publish());\n        // Set up side effects to bind inputs to the player.\n        playerObs.subscribe(player => {\n            this._player = player;\n            if (player && this._pendingPlayerState) {\n                this._initializePlayer(player, this._pendingPlayerState);\n            }\n            this._pendingPlayerState = undefined;\n        });\n        bindSizeToPlayer(playerObs, this._width, this._height);\n        bindSuggestedQualityToPlayer(playerObs, this._suggestedQuality);\n        bindCueVideoCall(playerObs, this._videoId, this._startSeconds, this._endSeconds, this._suggestedQuality, this._destroyed);\n        // After all of the subscriptions are set up, connect the observable.\n        playerObs.connect();\n    }\n    ngAfterViewInit() {\n        this._youtubeContainer.next(this.youtubeContainer.nativeElement);\n    }\n    ngOnDestroy() {\n        if (this._player) {\n            this._player.destroy();\n            window.onYouTubeIframeAPIReady = this._existingApiReadyCallback;\n        }\n        this._playerChanges.complete();\n        this._videoId.complete();\n        this._height.complete();\n        this._width.complete();\n        this._startSeconds.complete();\n        this._endSeconds.complete();\n        this._suggestedQuality.complete();\n        this._youtubeContainer.complete();\n        this._playerVars.complete();\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#playVideo */\n    playVideo() {\n        if (this._player) {\n            this._player.playVideo();\n        }\n        else {\n            this._getPendingState().playbackState = YT.PlayerState.PLAYING;\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#pauseVideo */\n    pauseVideo() {\n        if (this._player) {\n            this._player.pauseVideo();\n        }\n        else {\n            this._getPendingState().playbackState = YT.PlayerState.PAUSED;\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#stopVideo */\n    stopVideo() {\n        if (this._player) {\n            this._player.stopVideo();\n        }\n        else {\n            // It seems like YouTube sets the player to CUED when it's stopped.\n            this._getPendingState().playbackState = YT.PlayerState.CUED;\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#seekTo */\n    seekTo(seconds, allowSeekAhead) {\n        if (this._player) {\n            this._player.seekTo(seconds, allowSeekAhead);\n        }\n        else {\n            this._getPendingState().seek = { seconds, allowSeekAhead };\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#mute */\n    mute() {\n        if (this._player) {\n            this._player.mute();\n        }\n        else {\n            this._getPendingState().muted = true;\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#unMute */\n    unMute() {\n        if (this._player) {\n            this._player.unMute();\n        }\n        else {\n            this._getPendingState().muted = false;\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#isMuted */\n    isMuted() {\n        if (this._player) {\n            return this._player.isMuted();\n        }\n        if (this._pendingPlayerState) {\n            return !!this._pendingPlayerState.muted;\n        }\n        return false;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#setVolume */\n    setVolume(volume) {\n        if (this._player) {\n            this._player.setVolume(volume);\n        }\n        else {\n            this._getPendingState().volume = volume;\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getVolume */\n    getVolume() {\n        if (this._player) {\n            return this._player.getVolume();\n        }\n        if (this._pendingPlayerState && this._pendingPlayerState.volume != null) {\n            return this._pendingPlayerState.volume;\n        }\n        return 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#setPlaybackRate */\n    setPlaybackRate(playbackRate) {\n        if (this._player) {\n            return this._player.setPlaybackRate(playbackRate);\n        }\n        else {\n            this._getPendingState().playbackRate = playbackRate;\n        }\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getPlaybackRate */\n    getPlaybackRate() {\n        if (this._player) {\n            return this._player.getPlaybackRate();\n        }\n        if (this._pendingPlayerState && this._pendingPlayerState.playbackRate != null) {\n            return this._pendingPlayerState.playbackRate;\n        }\n        return 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getAvailablePlaybackRates */\n    getAvailablePlaybackRates() {\n        return this._player ? this._player.getAvailablePlaybackRates() : [];\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getVideoLoadedFraction */\n    getVideoLoadedFraction() {\n        return this._player ? this._player.getVideoLoadedFraction() : 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getPlayerState */\n    getPlayerState() {\n        if (!this._isBrowser || !window.YT) {\n            return undefined;\n        }\n        if (this._player) {\n            return this._player.getPlayerState();\n        }\n        if (this._pendingPlayerState && this._pendingPlayerState.playbackState != null) {\n            return this._pendingPlayerState.playbackState;\n        }\n        return YT.PlayerState.UNSTARTED;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getCurrentTime */\n    getCurrentTime() {\n        if (this._player) {\n            return this._player.getCurrentTime();\n        }\n        if (this._pendingPlayerState && this._pendingPlayerState.seek) {\n            return this._pendingPlayerState.seek.seconds;\n        }\n        return 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getPlaybackQuality */\n    getPlaybackQuality() {\n        return this._player ? this._player.getPlaybackQuality() : 'default';\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getAvailableQualityLevels */\n    getAvailableQualityLevels() {\n        return this._player ? this._player.getAvailableQualityLevels() : [];\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getDuration */\n    getDuration() {\n        return this._player ? this._player.getDuration() : 0;\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getVideoUrl */\n    getVideoUrl() {\n        return this._player ? this._player.getVideoUrl() : '';\n    }\n    /** See https://developers.google.com/youtube/iframe_api_reference#getVideoEmbedCode */\n    getVideoEmbedCode() {\n        return this._player ? this._player.getVideoEmbedCode() : '';\n    }\n    /** Gets an object that should be used to store the temporary API state. */\n    _getPendingState() {\n        if (!this._pendingPlayerState) {\n            this._pendingPlayerState = {};\n        }\n        return this._pendingPlayerState;\n    }\n    /** Initializes a player from a temporary state. */\n    _initializePlayer(player, state) {\n        const { playbackState, playbackRate, volume, muted, seek } = state;\n        switch (playbackState) {\n            case YT.PlayerState.PLAYING:\n                player.playVideo();\n                break;\n            case YT.PlayerState.PAUSED:\n                player.pauseVideo();\n                break;\n            case YT.PlayerState.CUED:\n                player.stopVideo();\n                break;\n        }\n        if (playbackRate != null) {\n            player.setPlaybackRate(playbackRate);\n        }\n        if (volume != null) {\n            player.setVolume(volume);\n        }\n        if (muted != null) {\n            muted ? player.mute() : player.unMute();\n        }\n        if (seek != null) {\n            player.seekTo(seek.seconds, seek.allowSeekAhead);\n        }\n    }\n    /** Gets an observable that adds an event listener to the player when a user subscribes to it. */\n    _getLazyEmitter(name) {\n        // Start with the stream of players. This way the events will be transferred\n        // over to the new player if it gets swapped out under-the-hood.\n        return this._playerChanges.pipe(\n        // Switch to the bound event. `switchMap` ensures that the old event is removed when the\n        // player is changed. If there's no player, return an observable that never emits.\n        switchMap(player => {\n            return player\n                ? fromEventPattern((listener) => {\n                    player.addEventListener(name, listener);\n                }, (listener) => {\n                    // The API seems to throw when we try to unbind from a destroyed player and it doesn't\n                    // expose whether the player has been destroyed so we have to wrap it in a try/catch to\n                    // prevent the entire stream from erroring out.\n                    try {\n                        if (player.removeEventListener) {\n                            player.removeEventListener(name, listener);\n                        }\n                    }\n                    catch (_a) { }\n                })\n                : of();\n        }), \n        // By default we run all the API interactions outside the zone\n        // so we have to bring the events back in manually when they emit.\n        (source) => new Observable(observer => source.subscribe({\n            next: value => this._ngZone.run(() => observer.next(value)),\n            error: error => observer.error(error),\n            complete: () => observer.complete(),\n        })), \n        // Ensures that everything is cleared out on destroy.\n        takeUntil(this._destroyed));\n    }\n}\nYouTubePlayer.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: YouTubePlayer, deps: [{ token: i0.NgZone }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Component });\nYouTubePlayer.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.2.0\", type: YouTubePlayer, selector: \"youtube-player\", inputs: { videoId: \"videoId\", height: \"height\", width: \"width\", startSeconds: \"startSeconds\", endSeconds: \"endSeconds\", suggestedQuality: \"suggestedQuality\", playerVars: \"playerVars\", showBeforeIframeApiLoads: \"showBeforeIframeApiLoads\" }, outputs: { ready: \"ready\", stateChange: \"stateChange\", error: \"error\", apiChange: \"apiChange\", playbackQualityChange: \"playbackQualityChange\", playbackRateChange: \"playbackRateChange\" }, viewQueries: [{ propertyName: \"youtubeContainer\", first: true, predicate: [\"youtubeContainer\"], descendants: true }], ngImport: i0, template: '<div #youtubeContainer></div>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: YouTubePlayer, decorators: [{\n            type: Component,\n            args: [{\n                    selector: 'youtube-player',\n                    changeDetection: ChangeDetectionStrategy.OnPush,\n                    encapsulation: ViewEncapsulation.None,\n                    // This div is *replaced* by the YouTube player embed.\n                    template: '<div #youtubeContainer></div>',\n                }]\n        }], ctorParameters: function () {\n        return [{ type: i0.NgZone }, { type: Object, decorators: [{\n                        type: Inject,\n                        args: [PLATFORM_ID]\n                    }] }];\n    }, propDecorators: { videoId: [{\n                type: Input\n            }], height: [{\n                type: Input\n            }], width: [{\n                type: Input\n            }], startSeconds: [{\n                type: Input\n            }], endSeconds: [{\n                type: Input\n            }], suggestedQuality: [{\n                type: Input\n            }], playerVars: [{\n                type: Input\n            }], showBeforeIframeApiLoads: [{\n                type: Input\n            }], ready: [{\n                type: Output\n            }], stateChange: [{\n                type: Output\n            }], error: [{\n                type: Output\n            }], apiChange: [{\n                type: Output\n            }], playbackQualityChange: [{\n                type: Output\n            }], playbackRateChange: [{\n                type: Output\n            }], youtubeContainer: [{\n                type: ViewChild,\n                args: ['youtubeContainer']\n            }] } });\n/** Listens to changes to the given width and height and sets it on the player. */\nfunction bindSizeToPlayer(playerObs, widthObs, heightObs) {\n    return combineLatest([playerObs, widthObs, heightObs]).subscribe(([player, width, height]) => player && player.setSize(width, height));\n}\n/** Listens to changes from the suggested quality and sets it on the given player. */\nfunction bindSuggestedQualityToPlayer(playerObs, suggestedQualityObs) {\n    return combineLatest([playerObs, suggestedQualityObs]).subscribe(([player, suggestedQuality]) => player && suggestedQuality && player.setPlaybackQuality(suggestedQuality));\n}\n/**\n * Returns an observable that emits the loaded player once it's ready. Certain properties/methods\n * won't be available until the iframe finishes loading.\n * @param onAbort Callback function that will be invoked if the player loading was aborted before\n * it was able to complete. Can be used to clean up any loose references.\n */\nfunction waitUntilReady(onAbort) {\n    return mergeMap(player => {\n        if (!player) {\n            return of(undefined);\n        }\n        if (playerIsReady(player)) {\n            return of(player);\n        }\n        // Since removeEventListener is not on Player when it's initialized, we can't use fromEvent.\n        // The player is not initialized fully until the ready is called.\n        return new Observable(emitter => {\n            let aborted = false;\n            let resolved = false;\n            const onReady = (event) => {\n                resolved = true;\n                if (!aborted) {\n                    event.target.removeEventListener('onReady', onReady);\n                    emitter.next(event.target);\n                }\n            };\n            player.addEventListener('onReady', onReady);\n            return () => {\n                aborted = true;\n                if (!resolved) {\n                    onAbort(player);\n                }\n            };\n        }).pipe(take(1), startWith(undefined));\n    });\n}\n/** Create an observable for the player based on the given options. */\nfunction createPlayerObservable(youtubeContainer, videoIdObs, iframeApiAvailableObs, widthObs, heightObs, playerVarsObs, ngZone) {\n    const playerOptions = combineLatest([videoIdObs, playerVarsObs]).pipe(withLatestFrom(combineLatest([widthObs, heightObs])), map(([constructorOptions, sizeOptions]) => {\n        const [videoId, playerVars] = constructorOptions;\n        const [width, height] = sizeOptions;\n        return videoId ? { videoId, playerVars, width, height } : undefined;\n    }));\n    return combineLatest([youtubeContainer, playerOptions, of(ngZone)]).pipe(skipUntilRememberLatest(iframeApiAvailableObs), scan(syncPlayerState, undefined), distinctUntilChanged());\n}\n/** Skips the given observable until the other observable emits true, then emit the latest. */\nfunction skipUntilRememberLatest(notifier) {\n    return pipe(combineLatest$1(notifier), skipWhile(([_, doneSkipping]) => !doneSkipping), map(([value]) => value));\n}\n/** Destroy the player if there are no options, or create the player if there are options. */\nfunction syncPlayerState(player, [container, videoOptions, ngZone]) {\n    if (player && videoOptions && player.playerVars !== videoOptions.playerVars) {\n        // The player needs to be recreated if the playerVars are different.\n        player.destroy();\n    }\n    else if (!videoOptions) {\n        if (player) {\n            // Destroy the player if the videoId was removed.\n            player.destroy();\n        }\n        return;\n    }\n    else if (player) {\n        return player;\n    }\n    // Important! We need to create the Player object outside of the `NgZone`, because it kicks\n    // off a 250ms setInterval which will continually trigger change detection if we don't.\n    const newPlayer = ngZone.runOutsideAngular(() => new YT.Player(container, videoOptions));\n    newPlayer.videoId = videoOptions.videoId;\n    newPlayer.playerVars = videoOptions.playerVars;\n    return newPlayer;\n}\n/**\n * Call cueVideoById if the videoId changes, or when start or end seconds change. cueVideoById will\n * change the loaded video id to the given videoId, and set the start and end times to the given\n * start/end seconds.\n */\nfunction bindCueVideoCall(playerObs, videoIdObs, startSecondsObs, endSecondsObs, suggestedQualityObs, destroyed) {\n    const cueOptionsObs = combineLatest([startSecondsObs, endSecondsObs]).pipe(map(([startSeconds, endSeconds]) => ({ startSeconds, endSeconds })));\n    // Only respond to changes in cue options if the player is not running.\n    const filteredCueOptions = cueOptionsObs.pipe(filterOnOther(playerObs, player => !!player && !hasPlayerStarted(player)));\n    // If the video id changed, there's no reason to run 'cue' unless the player\n    // was initialized with a different video id.\n    const changedVideoId = videoIdObs.pipe(filterOnOther(playerObs, (player, videoId) => !!player && player.videoId !== videoId));\n    // If the player changed, there's no reason to run 'cue' unless there are cue options.\n    const changedPlayer = playerObs.pipe(filterOnOther(combineLatest([videoIdObs, cueOptionsObs]), ([videoId, cueOptions], player) => !!player &&\n        (videoId != player.videoId || !!cueOptions.startSeconds || !!cueOptions.endSeconds)));\n    merge(changedPlayer, changedVideoId, filteredCueOptions)\n        .pipe(withLatestFrom(combineLatest([playerObs, videoIdObs, cueOptionsObs, suggestedQualityObs])), map(([_, values]) => values), takeUntil(destroyed))\n        .subscribe(([player, videoId, cueOptions, suggestedQuality]) => {\n        if (!videoId || !player) {\n            return;\n        }\n        player.videoId = videoId;\n        player.cueVideoById(Object.assign({ videoId,\n            suggestedQuality }, cueOptions));\n    });\n}\nfunction hasPlayerStarted(player) {\n    const state = player.getPlayerState();\n    return state !== YT.PlayerState.UNSTARTED && state !== YT.PlayerState.CUED;\n}\nfunction playerIsReady(player) {\n    return 'getPlayerStatus' in player;\n}\n/** Combines the two observables temporarily for the filter function. */\nfunction filterOnOther(otherObs, filterFn) {\n    return pipe(withLatestFrom(otherObs), filter(([value, other]) => filterFn(other, value)), map(([value]) => value));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst COMPONENTS = [YouTubePlayer];\nclass YouTubePlayerModule {\n}\nYouTubePlayerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: YouTubePlayerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nYouTubePlayerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: YouTubePlayerModule, declarations: [YouTubePlayer], exports: [YouTubePlayer] });\nYouTubePlayerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: YouTubePlayerModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: YouTubePlayerModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: COMPONENTS,\n                    exports: COMPONENTS,\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { YouTubePlayer, YouTubePlayerModule };\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function skipWhile(predicate) {\n    return operate((source, subscriber) => {\n        let taking = false;\n        let index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => (taking || (taking = !predicate(value, index++))) && subscriber.next(value)));\n    });\n}\n","import { Subject } from '../Subject';\nimport { multicast } from './multicast';\nimport { connect } from './connect';\nexport function publish(selector) {\n    return selector ? (source) => connect(selector)(source) : (source) => multicast(new Subject())(source);\n}\n","import { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { isFunction } from '../util/isFunction';\nimport { connect } from './connect';\nexport function multicast(subjectOrSubjectFactory, selector) {\n    const subjectFactory = isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : () => subjectOrSubjectFactory;\n    if (isFunction(selector)) {\n        return connect(selector, {\n            connector: subjectFactory,\n        });\n    }\n    return (source) => new ConnectableObservable(source, subjectFactory);\n}\n","<ng-container [ngSwitch]=\"type\">\n  <img\n    *ngSwitchCase=\"'image'\"\n    [src]=\"image.sizes.large\"\n    [alt]=\"image.alt || image.title || image.name || ''\"\n    [width]=\"image.sizes['large-width']\"\n    [height]=\"image.sizes['large-height']\"\n  />\n\n  <div *ngSwitchCase=\"'video'\" class=\"showcase__iframe-container\">\n    <youtube-player [videoId]=\"videoId\" data-testid=\"yt-player\"></youtube-player>\n  </div>\n</ng-container>\n","import { Component, Input, OnInit, Inject } from '@angular/core'\n\nimport { getYoutubeId } from 'src/app/shared/util'\n\nimport { Image, ShowcaseType, VideoURL } from '../../models/post.model'\nimport { DOCUMENT } from '@angular/common'\n\n@Component({\n  selector: 'app-showcase',\n  templateUrl: './showcase.component.html',\n  styleUrls: ['./showcase.component.css'],\n})\nexport class ShowcaseComponent implements OnInit {\n  @Input() type: ShowcaseType\n  @Input() image: Image\n  @Input() video: VideoURL\n\n  public videoId: string\n\n  constructor(@Inject(DOCUMENT) private document: Document) {}\n\n  ngOnInit() {\n    if (this.type === 'video') {\n      this.videoId = getYoutubeId(this.video)\n\n      if (typeof YT === 'undefined') this.loadYouTubeAPI()\n    }\n  }\n\n  private loadYouTubeAPI() {\n    const tag = document.createElement('script')\n    tag.src = 'https://www.youtube.com/iframe_api'\n    this.document.body.appendChild(tag)\n  }\n}\n","<table>\n  <tbody>\n    <tr>\n      <th scope=\"row\">Kategorie:</th>\n      <td [innerHTML]=\"data.topic.name\"></td>\n    </tr>\n    <tr>\n      <th scope=\"row\">Semester:</th>\n      <td>\n        <span *ngFor=\"let s of data.semester\" [innerHTML]=\"s.name + '<br>'\"></span>\n      </td>\n    </tr>\n    <tr>\n      <th scope=\"row\">Erstellunsjahr:</th>\n      <td [innerHTML]=\"data.year\"></td>\n    </tr>\n    <tr>\n      <th scope=\"row\">{{ data.students.length > 1 ? 'Studierende' : 'Student*in' }}:</th>\n      <td>\n        <span *ngFor=\"let s of data.students\" [innerHTML]=\"s.name + '<br>'\"></span>\n      </td>\n    </tr>\n    <tr>\n      <th scope=\"row\">{{ data.lecturers.length > 1 ? 'Dozierende' : 'Dozent*in' }}:</th>\n      <td>\n        <span *ngFor=\"let d of data.lecturers\" [innerHTML]=\"d.name + '<br>'\"></span>\n      </td>\n    </tr>\n  </tbody>\n</table>\n","import { Component, Input } from '@angular/core'\n\nimport { Post } from '../../models/post.model'\n\n@Component({\n  selector: 'app-briefing',\n  templateUrl: './briefing.component.html',\n  styleUrls: ['./briefing.component.css'],\n})\nexport class BriefingComponent {\n  @Input() data: Post['acf']\n}\n","import { Component } from '@angular/core'\n\n@Component({\n  selector: 'app-loading-spinner',\n  templateUrl: './loading-spinner.component.html',\n  styleUrls: ['./loading-spinner.component.css'],\n})\nexport class LoadingSpinnerComponent {\n  constructor() {}\n}\n","<span class=\"post-detail__spinner\" style=\"font-style: normal\" role=\"img\" aria-hidden=\"true\"\n  >⏳</span\n>\n","<ng-container *ngIf=\"(isFetching$ | async) === false; else loadingSpinner\">\n  <section *ngIf=\"post$ | async as post; else notFound\">\n    <h2 [innerHTML]=\"post.title.rendered\"></h2>\n    <p class=\"post-detail__category\">\n      {{ post.categoryName }}\n      <span *ngIf=\"post.acf.tags.length\" class=\"post-detail__category__tags\">\n        – <span *ngFor=\"let tag of post.acf.tags\">{{ tag.name }}</span>\n      </span>\n    </p>\n\n    <app-showcase\n      [type]=\"post.acf.showcaseType\"\n      [image]=\"post.acf.showcaseImage\"\n      [video]=\"post.acf.showcaseVideo\"\n    ></app-showcase>\n    <div [innerHTML]=\"post.acf.description\"></div>\n\n    <h3>Steckbrief</h3>\n    <app-briefing [data]=\"post.acf\"></app-briefing>\n\n    <h3 *ngIf=\"post.acf.gallery.length\">Galerie</h3>\n    <img\n      *ngFor=\"let image of post.acf.gallery\"\n      [src]=\"image.sizes.medium\"\n      [alt]=\"image.alt || image.title || image.name || ''\"\n      [width]=\"image.sizes['medium-width']\"\n      [height]=\"image.sizes['medium-height']\"\n    />\n\n    <footer class=\"post-detail__footer\">\n      <button type=\"button\" (click)=\"toTop()\">Nach oben</button>\n    </footer>\n  </section>\n</ng-container>\n\n<ng-template #notFound>\n  <p class=\"post-detail__status-msg\">\n    Projekt mit ID »{{ rawId }}« nicht gefunden.\n    <span style=\"font-style: normal\" role=\"img\" aria-label=\"Sad cat\">😿</span>\n  </p>\n</ng-template>\n\n<ng-template #loadingSpinner>\n  <p class=\"post-detail__status-msg\">Wird geladen... <app-loading-spinner></app-loading-spinner></p>\n</ng-template>\n","import { Component, OnInit } from '@angular/core'\nimport { ActivatedRoute } from '@angular/router'\n\nimport { Observable } from 'rxjs'\nimport { map } from 'rxjs/operators'\n\nimport { Select, Store } from '@ngxs/store'\nimport { GetPost } from '../../store/portfolio.actions'\nimport { PortfolioSelectors } from '../../store/portfolio.selectors'\n\ntype PostEntityByIdFn = ReturnType<typeof PortfolioSelectors.postEntityByIdFn>\n\n@Component({\n  selector: 'app-post-detail',\n  templateUrl: './post-detail.component.html',\n  styleUrls: ['./post-detail.component.css'],\n})\nexport class PostDetailComponent implements OnInit {\n  @Select(PortfolioSelectors.postEntityByIdFn) postEntityByIdFn$: Observable<PostEntityByIdFn>\n  rawId: string\n  id: number\n\n  postEntity$: Observable<ReturnType<PostEntityByIdFn>>\n  post$: Observable<ReturnType<PostEntityByIdFn>['entity']>\n  isFetching$: Observable<boolean>\n\n  constructor(route: ActivatedRoute, private store: Store) {\n    this.rawId = route.snapshot.paramMap.get('id')\n    this.id = Number(this.rawId)\n  }\n\n  ngOnInit() {\n    this.postEntity$ = this.postEntityByIdFn$.pipe(map((postEntityById) => postEntityById(this.id)))\n    this.post$ = this.postEntity$.pipe(map((post) => post.entity))\n    this.isFetching$ = this.postEntity$.pipe(map((post) => post.isFetching))\n\n    this.store.dispatch(new GetPost(this.id)).subscribe()\n  }\n\n  toTop() {\n    document.body.scrollIntoView({ block: 'start', behavior: 'smooth' })\n  }\n}\n","<h2>DMP Portfolio</h2>\n<ng-container *ngIf=\"(posts$ | async).length; else noPosts\">\n  <section *ngFor=\"let post of posts$ | async; first as isFirst\">\n    <hr *ngIf=\"!isFirst\" />\n    <h3 [innerHTML]=\"post.title.rendered\"></h3>\n    <div>\n      <div [innerHTML]=\"getTeaser(post.acf.description)\"></div>\n      <a routerLink=\"{{ post.id }}\">Projekt ansehen →</a>\n    </div>\n  </section>\n\n  <footer class=\"post-master__footer\">\n    <button\n      *ngIf=\"(query$ | async).totalPages > pagination.page && (isFetching$ | async) === false\"\n      (click)=\"requestNextPage()\"\n      type=\"button\"\n    >\n      Mehr laden...\n    </button>\n  </footer>\n</ng-container>\n\n<ng-template #noPosts>\n  <p *ngIf=\"(isFetching$ | async) === false\" class=\"post-master__status-msg\">\n    Keine Projekte vorhanden. <span aria-hidden=\"true\" style=\"font-style: normal\">🚫</span>\n  </p>\n</ng-template>\n\n<p *ngIf=\"isFetching$ | async\" class=\"post-master__status-msg\">\n  Projekte werden geladen... <app-loading-spinner></app-loading-spinner>\n</p>\n","import { Component, OnInit } from '@angular/core'\n\nimport { Observable } from 'rxjs'\nimport { map } from 'rxjs/operators'\n\nimport { Select, Store } from '@ngxs/store'\nimport { Post } from '../../models/post.model'\nimport { PostRequestOptions } from '../../posts.service'\nimport { GetPostPage } from '../../store/portfolio.actions'\nimport { PortfolioSelectors } from '../../store/portfolio.selectors'\n\nconst linebreakRegex = /<br\\s?\\/?>(<\\/br>)?/g\n\ntype PostQueryFn = ReturnType<typeof PortfolioSelectors.postQueryFn>\ntype EntitiesByQueryFn$ = Observable<ReturnType<typeof PortfolioSelectors.postEntitiesByQueryFn>>\n\n@Component({\n  selector: 'app-post-master',\n  templateUrl: './post-master.component.html',\n  styleUrls: ['./post-master.component.css'],\n})\nexport class PostMasterComponent implements OnInit {\n  @Select(PortfolioSelectors.postQueryFn) postQueryFn$: Observable<PostQueryFn>\n  @Select(PortfolioSelectors.postEntitiesByQueryFn) postEntitiesByQueryFn$: EntitiesByQueryFn$\n  pagination: PostRequestOptions = { page: 1, perPage: 8 }\n\n  posts$: Observable<Post[]>\n  query$: Observable<ReturnType<PostQueryFn>>\n  isFetching$: Observable<boolean>\n\n  constructor(private store: Store) {}\n\n  ngOnInit() {\n    this.posts$ = this.postEntitiesByQueryFn$.pipe(\n      map((postsForQuery) => postsForQuery(this.pagination)),\n      map((postEntities) => postEntities.map((p) => p.entity)),\n    )\n    this.query$ = this.postQueryFn$.pipe(map((getPostQuery) => getPostQuery(this.pagination)))\n    this.isFetching$ = this.query$.pipe(\n      map((q) => Object.values(q.pages).some((p) => p.isFetching)),\n    )\n    this.loadPage()\n  }\n  loadPage() {\n    this.store.dispatch(new GetPostPage(this.pagination))\n  }\n  requestNextPage() {\n    this.pagination.page++\n    this.loadPage()\n  }\n\n  getTeaser(text: string) {\n    text = text.replace(linebreakRegex, '')\n\n    return text.length < 160 ? text : `${text.slice(0, 160)}...`\n  }\n}\n","import { RouterModule, Routes } from '@angular/router'\n\nimport { PostDetailComponent } from './views/post-detail/post-detail.component'\nimport { PostMasterComponent } from './views/post-master/post-master.component'\n\nconst routes: Routes = [\n  { path: '', component: PostMasterComponent },\n  { path: ':id', component: PostDetailComponent },\n]\n\nexport const PortfolioRoutes = RouterModule.forChild(routes)\n","import { CommonModule } from '@angular/common'\nimport { NgModule } from '@angular/core'\n\nimport { LoadingSpinnerComponent } from './loading-spinner.component'\n\n@NgModule({\n  imports: [CommonModule],\n  declarations: [LoadingSpinnerComponent],\n  exports: [LoadingSpinnerComponent],\n})\nexport class LoadingSpinnerModule {}\n","import { CommonModule } from '@angular/common'\nimport { NgModule } from '@angular/core'\nimport { YouTubePlayerModule } from '@angular/youtube-player'\n\nimport { LoadingSpinnerModule } from 'src/app/shared/components/loading-spinner/loading-spinner.module'\n\nimport { BriefingComponent } from '../../components/briefing/briefing.component'\nimport { ShowcaseComponent } from '../../components/showcase/showcase.component'\n\nimport { PostDetailComponent } from './post-detail.component'\n\n@NgModule({\n  imports: [CommonModule, YouTubePlayerModule, LoadingSpinnerModule],\n  declarations: [PostDetailComponent, ShowcaseComponent, BriefingComponent],\n})\nexport class PostDetailModule {}\n","import { CommonModule } from '@angular/common'\nimport { NgModule } from '@angular/core'\nimport { RouterModule } from '@angular/router'\n\nimport { LoadingSpinnerModule } from 'src/app/shared/components/loading-spinner/loading-spinner.module'\n\nimport { PostMasterComponent } from './post-master.component'\n\n@NgModule({\n  imports: [CommonModule, RouterModule, LoadingSpinnerModule],\n  providers: [],\n  declarations: [PostMasterComponent],\n})\nexport class PostMasterModule {}\n","import { CommonModule } from '@angular/common'\nimport { NgModule } from '@angular/core'\n\nimport { NgxsModule } from '@ngxs/store'\n\nimport { PortfolioRoutes } from './portfolio.module.routing'\nimport { PortfolioState } from './store/portfolio.state'\nimport { PostDetailModule } from './views/post-detail/post-detail.module'\nimport { PostMasterModule } from './views/post-master/post-master.module'\n\n@NgModule({\n  imports: [\n    CommonModule,\n    PortfolioRoutes,\n    PostMasterModule,\n    PostDetailModule,\n    NgxsModule.forFeature([PortfolioState]),\n  ],\n  declarations: [],\n})\nexport class PortfolioModule {}\n"],"sourceRoot":"webpack:///","file":"src_app_portfolio_portfolio_module_ts.7526e0fd11e12291.js"}